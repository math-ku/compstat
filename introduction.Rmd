---
title: "Introduction"
subtitle: Computational Statistics
author: "Johan Larsson, Niels Richard Hansen"
date: "September 3, 2024"
output: xaringan::moon_reader
---

```{r init, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(gridExtra)

knitr::knit_hooks$set(crop = knitr::hook_pdfcrop)

knitr::opts_chunk$set(
  fig.width = 4.8,
  fig.height = 4.2,
  fig.retina = 3,
  fig.align = "center",
  cache = TRUE,
  autodep = TRUE,
  crop = TRUE
)

load(file.path("data", "top100dih.RData"))
phipsi2 <- na.omit(dataset)
phipsi <- read.table(file.path("data", "phipsi.tsv"), header = TRUE)
phipsi[, c("phi", "psi")] <- pi * phipsi[, c("phi", "psi")] / 180

theme_set(theme_grey(base_size = 18))

options(width = 80)
```

## Computational Statistics

TBW

---

## Teaching Staff

.pull-left[
### Instructor

Johan Larsson, postdoctoral researcher

```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics(file.path("images/johan.jpg"))
```
]

.pull-right[
### Teaching Assistant

Jinyang Liu, PhD student

```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics(file.path("images/jinyang.jpg"))
```
]

*See Absalon for contact information.*

---

## Topics

### Problems

* Computing nonparametric estimates
* Computing integrals (and probabilities)
  $E f(X) = \int f(X) dP \left(P(X \in A) = \int_{(X \in A)} \ dP\right)$.
* Optimizing the likelihood

--

### Methods

* Numerical linear algebra
* Monte Carlo integration
* The EM-algorithm, stochastic gradient descent

---

## Example: Amino Acid Angles

```{r PhiPsi, echo = FALSE, out.height=400, out.width=400, fig.align='center'}
knitr::include_graphics("images/PhiPsi_creative.jpg")
```

---
## Ramachandran Plot

.two-column-left[
```{r phipsi-plot1}
ggplot(phipsi, aes(phi, psi)) + 
  geom_point(alpha = 0.2)
```
]
--

.two-column-right[
```{r phipsi-plot2}
ggplot(phipsi2, aes(phi, psi)) +
  geom_point(alpha = 0.2)
```
]

---
## Histograms


.two-column-left[
```{r hist1}
hist(
  phipsi$phi,
  prob = TRUE,
  xlab = expression(phi),
  main = NULL
)
rug(phipsi$phi)
```
]

--

.two-column-right[
```{r hist2}
hist(
  phipsi$psi,
  prob = TRUE,
  xlab = expression(psi),
  main = NULL
)
rug(phipsi$psi)
```
]
---
## Density Estimation

.two-column-left[
```{r dens1, eval = FALSE}
lines(
  density(phipsi$phi),
  col = "red",
  lwd = 2
)
```


```{r, echo = FALSE}
<<hist1>>
<<dens1>>
```
]
--

.two-column-right[
```{r dens2, eval = FALSE}
lines(
  density(phipsi$psi),
  col = "red",
  lwd = 2
)
```

```{r, echo = FALSE}
<<hist2>>
<<dens2>>
```
]

---
## Statistical Topics of the Course

* **Smoothing:** what does `density()` do?
--

    + How do we compute nonparametric estimators?
    + How do we choose tuning parameters?
--


* **Simulation:** how do we efficiently simulate from a target distribution?
--

    + How do we assess results from Monte Carlo methods?
    + What if we cannot compute the density?
--


* **Optimization:** how do we compute the MLE?
--

    + What if we cannot compute the likelihood?
    + How to deal with very large data sets?


---
## Computational Topics of the Course

* **Implementation**: writing statistical software.
--

    + R data structures and functions
    + S3 object oriented programming
--


* **Correctness**: does the implementation do the right thing?
--

    + testing
    + debugging
    + accuracy of numerical computations
--


* **Efficiency**: minimize memory and time usage.
--

    + benchmark code for comparison
    + profile code for identifying bottlenecks
    + optimize code (Rcpp)

---
## Course Work

.pull-left[
### Assignments

- Eight assignments covering four topics
- Register in Absalon for the presentation of 
  one assignment solution. 
- Presentations are done in groups of two-three students. 
- On four Thursdays there will be presentations with discussion and feedback.
- For the exam you need to prepare four *individual* presentations, one for each topic assignment.
]

--

.pull-right[
### Examination

- Oral exam
- For each of the four topics you choose one out of two assignments to 
prepare for the exam.
- Assessment is based on your presentation *on the basis of the 
entire content of the course*.
- Get started immediately and work continuously on the assignments as the
course progresses. 
]

---

## Learning Platform: Absalon

- **Course Material**: Slides, videos,, data, groups, and assignments.
- [absalon.ku.dk](https://absalon.ku.dk/)
- Actually based on Canvas (but rebranded for UCPH).
- Download Canvas Student app for your phone.

---
## Prerequisites in R 

Good working knowledge of:

* Data structures (vectors, lists, data frames).
--

* Control structures (loops, if-then-else).
--

* Function calling.
--

* Interactive and script usages (`source`) of R.
--

* You don't need to be an experienced programmer.

---
## Exercise

```{r, echo = FALSE, out.height=NULL, out.width=200, fig.align='center'}
knitr::include_graphics("images/PracIcon.png")
```

With `x` a vector of numbers, write code in R to compute a vector 
`y` of logicals such that `y[i]` is `TRUE` whenever `x[i] > 0`. E.g. 

```{r, echo=3:4}
x <- c(-1, 0, 1, 2)
y <- c(FALSE, FALSE, TRUE, TRUE)
x
y
```


---
## Vectors in R

Think of a vector as a column with a number of entries.

### Atomic Vectors

All components are of the same type, e.g.

  + integers
  + numbers
  + logical values
  + character strings

--

### Lists

May contain components of different types, including components which themselves are lists. 

--

Atomic vectors and lists are important building blocks of data structures in R.

---
## Atomic Vectors and Subsetting

Example of a vector
```{r my_vector}
my_vector <- c(1.1, 3.2, 90, 67.7, 10)
my_vector
```

--

You can extract components with `[]`.
```{r my_vector_subsetting, dependson = "my_vector"}
my_vector[1]
my_vector[c(1, 4)]
my_vector[-2] # Negative indices drop corresponding components
```

---
## Vectors of Class `integer`

```{r integer_vector}
integer_vector <- 1:10 #<<
integer_vector

class(integer_vector)
```
--

This is a vector of length 10, i.e. it has 10 elements.
```{r length, dependson = "integer_vector"}
length(integer_vector)
```

---
## Numerical Vectors

Example of a vector with non-integer values.
```{r numeric_vector}
numeric_vector <- seq(0.1, 1, by = 0.1)
numeric_vector

class(numeric_vector)
```

--

```{r}
typeof(numeric_vector) # Internal storage mode
```

---
## A Tricky (Non-)Integer Vector

Example of a vector with only seemingly integer values (and how to fix it).

```{r num_int_example}
x <- c(1, 4, 7, 9)
class(x)
```

--

```{r}
typeof(x)
```

--

```{r}
x <- c(1L, 4L, 7L, 9L)
class(x)
```

---
## Comparison of Numerical Values

Values in a vector of class numeric are approximate.
```{r numeric_vector_comparison, dependson = "numeric_vector"}
numeric_vector[2:3]
numeric_vector[2:3] == c(0.2, 0.3)
```

--

Function `all.equal` has a tolerance.
```{r numeric_vector_near, dependson = "numeric_vector", message = FALSE}
all.equal(numeric_vector[2:3], c(0.2, 0.3))
```

---
## Precision

```{r}
options(digits = 20) ## Precision of printed numbers increased
c(0.2, 0.3)
numeric_vector[2:3]
options(digits = 7) ## Default precision of printed numbers restored
```

--

Note that the internal storage precision is **not** changed by setting the `digits` 
option. It only affects the precision of printed numbers.

--

The differences arise because not all decimals are represented to arbitrary 
precision in the binary numeral system.


---
## Logical (Boolean) Vectors

Example of a logical vector.
```{r logical_vector, dependson = "integer_vector"}
logical_vector <- integer_vector > 4
logical_vector
class(logical_vector)
```
--

How many percent (%) of the components of `integer_vector` are (strictly) larger than 4?
--

```{r logcial_vector_mean, results = "hold", dependson = "integer_vector"}
mean(integer_vector > 4) * 100
```

---
## Character Vectors

Example of a character vector.
```{r character_vector}
character_vector <- c("A", "vector", "of", "length", 6, ".")
character_vector
```

--

```{r}
class(character_vector)
length(character_vector)
```

--

Observe that the number was coerced to a string.

---
## Factor (Categorical) Vectors

.pull-left[
Example of a factor.
```{r factor_vector}
factor_vector <- factor(c(
  "m", "m", "f", "m", "f",
  "m", "f", "f", "f", "m"
))
factor_vector
```
]

--

.pull-right[
```{r factor_vector_class}
class(factor_vector)
```

Might look like a character vector but is actually based on an integer vector.

```{r}
typeof(factor_vector)
```
]

--

### Notes

* Can only take a fixed set of values (default: values present in data).
--

* Possibility of reordering levels convenient e.g. for plots.

---
## Date Vectors

Example of a date vector.

```{r date_vector}
date_vector <- seq(Sys.Date(), length.out = 4, by = "quarter")
date_vector
class(date_vector)
```

--

Date vectors might also look like character vectors, but they are based on numeric vectors.


---
## Lists

A list with named elements.

.pull-left[
```{r my_list, dependson = "integer_vector, factor_vector, logical_vector, date_vector", results="hide"}
my_list <- list(
  my_integers = integer_vector,
  my_factor = factor_vector,
  my_logicals = logical_vector,
  my_dates = date_vector
)

my_list
```
]

.pull-right[
```{r my_list_output, echo=FALSE}
options(width = 35)
my_list
options(width = 100)
```
]

---
## Subsetting Lists

Example of a sublist.
```{r my_first_sublist, dependson = "my_list"}
my_first_sublist <- my_list[1:3]
my_first_sublist
```
--

```{r my_first_sublist_class, dependson = "my_first_sublist"}
class(my_first_sublist)
```

---
## Subsetting lists

Example of another sublist.
```{r my_second_sublist, dependson = "my_list"}
my_second_sublist <- my_list[4]
my_second_sublist
```
--

```{r my_second_sublist_class, dependson = "my_second_sublist"}
class(my_second_sublist)
```

---
## Subsetting Lists

Extracting components from a list.

```{r my_list_dates, dependson = "my_list"}
dates_from_list <- my_list$my_dates
dates_from_list
```
--

```{r}
class(dates_from_list)
```
--

The original date vector and the one extracted from the list are identical:
```{r identical_dates, dependson = "date_vector, my_list_dates"}
identical(date_vector, dates_from_list)
```

---
## Exercise

```{r, echo = FALSE, out.height=NULL, out.width=200, fig.align='center'}
knitr::include_graphics("images/PracIcon.png")
```

Run the following code and explain the differences/similarities.

```{r, eval=FALSE}
a_list <- list(foo = c(-1, 0, 1, 2))

a_list[1]
a_list[[1]]
a_list$foo
a_list[["foo"]]
```

---
## Data Frames

Example of a data frame.

```{r my_data frame, dependson = "my_first_sublist"}
my_data_frame <- as.data.frame(my_first_sublist)
my_data_frame
```
--

**Question:** Why does `as.data.frame(my_list)` produce an error? 


---
## Subsetting Data Frames

Extracting one column from a data frame by name.
```{r my_data_frame_integers, dependson = "my_data_frame"}
my_data_frame$my_integers
```
--

Extracting one column from a data frame using that it is a list.
```{r my_data_frame_integers2, dependson = "my_data_frame"}
my_data_frame[[1]]
```
--

Extracting one column from a data frame using data frame subsetting.
```{r my_data_frame_integers3, dependson = "my_data_frame"}
my_data_frame[, 1]
```

---
## Subsetting Data Frames

You can subset data frames using brackets

```{r}
my_data_frame[5, 1]
```

--

... and you can assign values to entries using brackets such as 

```{r}
my_data_frame[5, 1] <- NA
my_data_frame[1, 3] <- NA
```

---
## Functions

We introduced missing values in our data frame above. Suppose we want to 
impute a value whenever it's missing.
--

.pull-left[
```{r}
res <- within(
  my_data_frame,
  my_integers <- ifelse(
    is.na(my_integers),
    0,
    my_integers
  )
)

head(res, 4)
```
]

--

.pull-right[

However, this is a bit cumbersome to copy-paste around, and it's 
not completely clear what this code does. 

Let's write a function with a good name.

```{r}
impute_missing <- function(x) {
  ifelse(is.na(x), 0, x)
}
```
]


---
## Functions

```{r}
within(my_data_frame, my_integers <- impute_missing(my_integers))
```

---

## Exercise

Write a function, `is_pos`, which takes a vector `x` as argument and returns a
vector of logicals whose i-th entry is `TRUE` whenever `x[i] > 0`. E.g. 

```{r, echo=2}
is_pos <- function(x) x > 0
is_pos(c(-1, 0, 1, 2))
```


---
## Functions

What happens if we apply the `impute_missing` to other columns?

```{r}
impute_missing
```

--

```{r}
within(my_data_frame, my_logicals <- impute_missing(my_logicals))
```

---

## Better Impute Function

```{r}
impute_missing <- function(x, value = 0) {
  ifelse(is.na(x), value, x)
}
```
--


```{r}
within(my_data_frame, {
  my_integers <- impute_missing(my_integers)
  my_logicals <- impute_missing(my_logicals, value = FALSE)
})
```

---
## R Programming 

- R functions are fundamental. They don't do anything before they are called and the call is evaluated. 

--

- An R function takes a number of *arguments*, and when a function call is evaluated it computes a *return value*.

--

- An R program consists of a hierarchy of function calls. When the program is executed, function calls are evaluated and 
replaced by their return values. 

--

- Implementations of R functions are collected into source files, which can be organized into R packages.

--

- An R script (or R Markdown document) is a collection of R function calls, which, when evaluated, 
compute a desired result. 

--

- R programming includes activities at many different levels of sophistication and abstraction.

---

class: center, middle

# Functions

---

## Counting Number of Zeros in Data

Count data (values in $\mathbb{N}_0$) are often modeled using a Poisson 
distribution. R can simulate count data using the function `rpois()`.

```{r, echo=2}
set.seed(1234)
rpois(10, 2) # n = 10 variables from a Pois(2) distribution
```

--

In the above sequence, two of the values are zero. 

--

Zero-inflation is often encountered in practice, which means that the number
of zeros exceeds what is expected from Poisson variables. 

--

We need to count how many zeros there are in a data set. 

---
## Writing an R function

A function that counts the number of zeros in a vector.

```{r}
count_zeros <- function(x) {
  nr <- 0
  for (i in seq_along(x)) { # 1:length(x) wrong if length(x) is 0
    nr <- nr + (x[i] == 0)
  } # logical coerced to numeric
  nr
}
```

--
The implementation works in most programming languages:
--

* Initialize a counter to be 0.
* Loop through the elements of the vector.
* Increment the counter whenever an element equals zero.
* Return the value of the counter.

---
## Testing an R function

```{r}
tests <- list(
  c(0, 0, 0, 0, 25),
  c(0, 1, 10, 0, 5, -4, 2.5),
  c(2, 1, 10),
  c() # Extreme cases should be tested!
)
sapply(tests, count_zeros)
```

--
We can manually inspect that the results are correct, or we can do it programmatically.

```{r}
all(sapply(tests, count_zeros) == c(4, 2, 0, 0))
```

---
## Writing an R function, Version 2

```{r}
count_zeros_vec <- function(x) {
  sum(x == 0)
}
```

--
Testing:

```{r}
all(sapply(tests, count_zeros) == sapply(tests, count_zeros_vec))
```

---
## Vectorized R Code

```{r}
count_zeros_vec
```
--

* The expression `x == 0` tests each entry of the vector `x` for being equal to 0 and returns a vector of logicals.
--

* The `sum` function computes and returns the sum of all elements in a vector. Logicals are coerced to integers. 
--

* The vectorized implementation is short but expressive and easy to understand.
--

* The vectorized computations are performed by compiled code. They are faster to evaluate than R code.  
--

* Writing vectorized code requires a larger knowledge of R functions.


---
## However, All Is Not Well


```{r}
identical(
  sapply(tests, count_zeros),
  sapply(tests, count_zeros_vec)
)
```

---
## Why Are Results Equal But Not Identical!?

--
```{r}
typeof(sapply(tests, count_zeros))
```

--

```{r}
count_zeros <- function(x) {
  # counter now of type integer!
  nr <- 0L #<<
  for (i in seq_along(x)) {
    nr <- nr + (x[i] == 0)
  }
  nr
}
```

--

```{r}
typeof(sapply(tests, count_zeros))
```

---
## Results Are Now Identical

```{r}
identical(
  sapply(tests, count_zeros),
  sapply(tests, count_zeros_vec)
)
```

---
## Functions as Arguments

We have already used `sapply()` above with a function as its second argument.

--

It is a feature of R as a functional programming language that it can operate with
functions as with any other data structure. Functions can be arguments and return values.

--

Let's write our own apply function.

```{r own-apply}
our_apply <- function(x, fun) {
  val <- numeric(length(x)) # initialize vector of return values
  for (i in seq_along(x)) {
    val[i] <- fun(x[[i]])
  }
  val
}
```

---
## Testing Our Apply-Function

```{r}
sapply(tests, count_zeros_vec)
our_apply(tests, count_zeros_vec)
```

--

Our implementation assumes that `x` is a list, that `fun()` takes a single 
argument and that `fun()` returns a numeric. 

---
## What if `fun()` Needs Additional Arguments?

```{r, error=TRUE}
our_apply(1:10, rpois)
```

--

Generating Poisson distributed values requires two arguments, and the
code above resulted in an error. 

--

It is possible to "solve" this by an **anonymous** function.

```{r}
our_apply(1:10, function(lambda) rpois(1, lambda))
```

---
## The `...` Argument

It is possible to use a general construct via the `...` argument to pass any 
arguments on to the function.

```{r own-apply-2}
our_apply <- function(x, fun, ...) {
  val <- numeric(length(x))
  for (i in seq_along(x)) {
    val[i] <- fun(x[[i]], ...)
  }
  val
}
```

--

```{r}
our_apply(1:10, rpois, n = 1)
```

---

class: middle, center

# S3 Objects

---

## Functionals

The function `integrate()` takes a function as argument and returns the 
value of numerically integrating the function.
--


It is an example of a *functional*. 
--


```{r}
integral <- integrate(sin, 0, 1)
integral
```

The numerical value of the integral 
$$\int_0^1 \sin(x) \mathrm{d}x$$ 
is printed nicely above—including an indication of the numerical error. 

---
## Return Values

In fact, `integrate()` returns a list with a *class label*.

```{r}
str(integral)
```
--

Return values that don't fit into one of the basic data structures 
can be returned as a list as above.

---
## The Return Value of `integrate()`

The class label can be extracted directly.

```{r}
class(integral)
```
--


When you ask R to print this object it doesn't just print out all the values in the list. 
It gives a suitably formatted result as implemented 
in the print method for objects of class integrate. 

---
## Printing Objects of Class Integrate 

```{r}
stats:::print.integrate
```

(The `print.integrate()` function is not exported from the stats package. It is in the 
namespace of the stats package, and to access it directly we use `stats:::`.)

---
## Histogram Objects

```{r temp-hist, fig.width = 9, fig.height = 6}
phi_hist <- hist(phipsi$phi, main = NULL)
```

---
## Histogram Objects

```{r}
class(phi_hist)
```

--

```{r}
str(phi_hist)
```

---
## Histogram Objects

```{r}
phi_hist[1:4]
```


---
## Getting Help 

You can find documentation for `plot()` using e.g. 

```{r help-plot, eval = FALSE}
?plot
```

--
However, this will be uninformative on how an object of class histogram is plotted. 
Try instead 

```{r help-plot-histogram, eval = FALSE}
?plot.histogram
```

This will give the documentation for the plot method for objects of class histogram. 


---
## S3 Overview

* S3 classes are standard data structures (typically lists) with *class labels*.
--

* It is an informal system. No checks of object content.
--

* One implements a *generic* function via `UseMethod()`. E.g.
```{r, eval=FALSE}
plot
```

```{r, echo=FALSE}
cat(deparse(plot))
```

--

* **Methods** for specific classes are implemented as standard R functions 
with the naming convention `f.classname()` for a method for class `classname` of the function `f()`. 
--

* The system is widely used to write methods for the generic functions `print()`, 
`plot()` and `summary()`. 


---
## Constructing a New Class

```{r, echo=FALSE}
count_zeros_vec <- function(x) {
  sum(x == 0)
}
```

Recall the function `count_zeros_vec()` that counts the number of zeros in a vector.
--


If we need this number many times it is beneficial to compute it once and then 
extract it whenever needed. 

--

We first write a *constructor function* that returns a list with a class
label.

```{r}
count_object <- function(x) {
  structure(
    list(
      x = x,
      n = count_zeros_vec(x)
    ),
    class = "count_object"
  )
}
```

---
## A Data Example

```{r, echo=-1}
set.seed(1234)
count_data <- count_object(rpois(10, 2))
count_data
```

---
## The Generic Function and a Method

To activate looking up a method for a specific class, one needs to tell R 
that the function `count_zeros()` is a *generic function*. 

```{r}
count_zeros <- function(x) {
  UseMethod("count_zeros")
}
```

--
Then we can implement a class specific version of `count_zeros()`.

```{r}
count_zeros.count_object <- function(x) {
  x$n
}
```

--
And we can also implement a print method

```{r}
print.count_object <- function(x) {
  cat(x$x, "\n")
}
```

---
## Trying It Out

```{r}
count_data ## Print data
count_zeros(count_data)
```

---

class: center, middle

# Benchmarking

---

## R Is Slow ... 

... when used like a low-level language. 

--

- The language and its implementation have limitations in terms of speed and 
memory usage. It was designed to specify statistical models and carry out 
data analysis and not for high-performance computing.  
--

- It is a language suitable for high-level programming where most low-level computations 
are actually implemented in a compiled language and accessed via function calls. 
--


### Example: Numerical Linear Algebra

All basic operations with vectors and matrices from 
scalar multiplication (`10 * x`) over matrix products (`%*%` or `crossprod()`) to matrix decompositions (`eigen()` or `qr()`) are implemented in C or Fortran. 

---

## R Is Fast ...

... when most computations are carried out by calls to compiled code. 

```{r}
library(microbenchmark)

x <- rnorm(1e4)
loop_bench <- microbenchmark(
  for (i in seq_along(x)) 10 * x[i],
  10 * x
)
loop_bench <- summary(loop_bench)
```
--

```{r}
loop_bench[, c(1, 4, 5)]
```

```{r, echo = FALSE}
cat("units: ", attr(loop_bench, "unit"))
```

---
## "Vectorized" Computations May Not Be Fast

```{r}
apply_bench <- microbenchmark(
  sapply(x, function(z) 10 * z),
  10 * x
)
apply_bench <- summary(apply_bench)
```
--


```{r}
apply_bench[, c(1, 4, 5)]
```

```{r, echo = FALSE}
cat("units: ", attr(apply_bench, "unit"))
```

---
## Suggested (Real World) Development Cycle

* Can I find an existing implementation that solves my problem? Does it
solve my problem sufficiently well (fast enough, general enough)? If yes, I'm done.
--

* Implement a solution and test it. Does it
solve my problem sufficiently well? If yes, I'm done.
--

* Rewrite, improve and test the code. Use e.g. profiling tools to identify 
the computationally demanding parts of the code. 
--

* Use benchmaking tools to compare different implementations and to investigate 
how the computational demands scale. 
--

* If one implementation solves my problem sufficiently well, I'm done. Otherwise
reiterate the two previous points. 

---

## Density Implementation

```{r kernDens}
kern_dens <- function(x, h, m = 512) {
  rg <- range(x)
  xx <- seq(rg[1] - 3 * h, rg[2] + 3 * h, length.out = m)
  y <- numeric(m)

  for (i in seq_along(xx)) {
    for (j in seq_along(x)) { #<<
      y[i] <- y[i] + exp(-(xx[i] - x[j])^2 / (2 * h^2)) #<<
    } #<<
  }

  y <- y / (sqrt(2 * pi) * h * length(x))

  list(x = xx, y = y)
}
```


---

## Density Implementation (Vectorized)

```{r kernDens-vec}
kern_dens_vec <- function(x, h, m = 512) {
  rg <- range(x)
  xx <- seq(rg[1] - 3 * h, rg[2] + 3 * h, length.out = m)
  y <- numeric(m)
  const <- (sqrt(2 * pi) * h * length(x))

  for (i in seq_along(xx)) {
    y[i] <- sum(exp(-(xx[i] - x)^2 / (2 * h^2))) / const #<<
  }

  list(x = xx, y = y)
}
```

```{r, echo=FALSE}
kern_dens_apply <- function(x, h, m = 512) {
  rg <- range(x)
  xx <- seq(rg[1] - 3 * h, rg[2] + 3 * h, length.out = m)
  const <- sqrt(2 * pi) * h * length(x)
  y <- sapply(xx, function(z) sum(exp(-(z - x)^2 / (2 * h^2))) / const)
  list(x = xx, y = y)
}

kern_dens_outer <- function(x, h, m = 512) {
  rg <- range(x)
  xx <- seq(rg[1] - 3 * h, rg[2] + 3 * h, length.out = m)
  y <- outer(xx, x, function(zz, z) exp(-(zz - z)^2 / (2 * h^2)))
  y <- rowMeans(y) / (sqrt(2 * pi) * h)
  list(x = xx, y = y)
}
```


---

## Density Benchmarking

```{r, echo=FALSE}
phipsi <- read.table(file.path("data", "phipsi.tsv"), header = TRUE)
phipsi[, c("phi", "psi")] <- pi * phipsi[, c("phi", "psi")] / 180
psi <- phipsi$psi
```


```{r kern-bench, dependson=c("phipsiLoad", "kernDens", "kernDens-vec", "kernDens-apply", "kernDens-outer")}
kern_bench <- microbenchmark(
  kern_dens(psi, 0.2),
  kern_dens_vec(psi, 0.2),
  kern_dens_apply(psi, 0.2),
  kern_dens_outer(psi, 0.2)
)
```

```{r kern-bench-hidden, echo=FALSE, dependson="kern-bench"}
old_options <- options(digits = 3)
kern_bench
options(digits = old_options$digits)
```

---
## Plot

```{r kern-bench-autoplot, dependson="kern-bench-hidden", message=FALSE, fig.height=4.5, fig.width = 9}
autoplot(kern_bench) +
  geom_jitter(aes(color = expr), height = 0.2, width = 0, alpha = 0.4) +
  aes(fill = I("gray")) +
  theme(legend.position = "none")
```


---
## Systematic Benchmarking

A designed experiment

```{r kern-bench-grid, dependson=c("kernDens", "kernDens-vec", "kernDens-apply", "kernDens-outer")}
conf <- expand.grid(
  fun = c("kern_dens", "kern_dens_vec", "kern_dens_apply", "kern_dens_outer"),
  n = 2^(5:11),
  m = 2^c(5, 7, 9, 11)
)

set.seed(1234)
x <- rnorm(2^11)
calls <- paste0(conf[, 1], "(x[1:", conf[, 2], "], h = 0.2, m = ", conf[, 3], ")")
expr_list <- lapply(calls, function(x) parse(text = x)[[1]])

kern_benchmarks <- microbenchmark(list = expr_list, times = 40L)
```

---
## Results

```{r kern-bench-fig, echo=FALSE, message=FALSE, warning=FALSE, dependson="kern-bench-grid", fig.width=11, fig.height=7}
library(tidyverse)
class(kern_benchmarks) <- "data.frame"
kern_benchmarks <- bind_cols(conf, expr = calls) %>%
  left_join(kern_benchmarks, .)

kern_benchmarks$m <- factor(
  kern_benchmarks$m,
  levels = c(32, 128, 512, 2048),
  labels = c("m = 32", "m = 128", "m = 512", "m = 2048")
)

ggplot(kern_benchmarks, aes(x = n, y = time, color = fun)) +
  geom_abline(intercept = 15, slope = 1, color = "gray", linetype = 2) +
  stat_summary(fun.y = "median", geom = "line") +
  stat_summary(fun.y = "median", geom = "point") +
  facet_wrap(~m) +
  scale_x_continuous(trans = "log2") +
  scale_y_continuous("Time (ms)",
    trans = "log2",
    breaks = c(1e5, 1e6, 1e7, 1e8),
    labels = c("0.1", "1", "10", "100")
  ) +
  scale_color_discrete("Function:") +
  theme(legend.position = "top")
```



