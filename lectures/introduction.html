<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction</title>
    <meta charset="utf-8" />
    <meta name="author" content="Johan Larsson, Niels Richard Hansen" />
    <script src="introduction_files/header-attrs-2.27/header-attrs.js"></script>
    <link href="introduction_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="../assets/styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: middle, center, title-slide

.title[
# Introduction
]
.subtitle[
## Computational Statistics
]
.author[
### Johan Larsson, Niels Richard Hansen
]
.date[
### Sep 2, 2024
]

---


## Computational Statistics




--

### Problems

* Computing nonparametric estimates
* Computing integrals (and probabilities)
  `\(E f(X) = \int f(X) dP \left(P(X \in A) = \int_{(X \in A)} \ dP\right)\)`.
* Optimizing the likelihood

--

### Methods

* Numerical linear algebra
* Monte Carlo integration
* The EM-algorithm, stochastic gradient descent

---

## Example: Amino Acid Angles

&lt;img src="PhiPsi_creative.jpg" width="400" height="400" style="display: block; margin: auto;" /&gt;

---
## Ramachandran Plot

.two-column-left[

``` r
ggplot(phipsi, aes(phi, psi)) + 
  geom_point(alpha = 0.2)
```

&lt;img src="introduction_files/figure-html/phipsi-plot1-1.png" width="345.6" style="display: block; margin: auto;" /&gt;
]
--

.two-column-right[

``` r
ggplot(phipsi2, aes(phi, psi)) +
  geom_point(alpha = 0.2)
```

&lt;img src="introduction_files/figure-html/phipsi-plot2-1.png" width="345.6" style="display: block; margin: auto;" /&gt;
]

---
## Histograms


.two-column-left[

``` r
hist(
  phipsi$phi,
  prob = TRUE,
  xlab = expression(phi),
  main = NULL
)
rug(phipsi$phi)
```

&lt;img src="introduction_files/figure-html/hist1-1.png" width="345.6" style="display: block; margin: auto;" /&gt;
]

--

.two-column-right[

``` r
hist(
  phipsi$psi,
  prob = TRUE,
  xlab = expression(psi),
  main = NULL
)
rug(phipsi$psi)
```

&lt;img src="introduction_files/figure-html/hist2-1.png" width="345.6" style="display: block; margin: auto;" /&gt;
]
---
## Density Estimation

.two-column-left[

``` r
lines(
  density(phipsi$phi),
  col = "red",
  lwd = 2
)
```


&lt;img src="introduction_files/figure-html/unnamed-chunk-1-1.png" width="345.6" style="display: block; margin: auto;" /&gt;
]
--

.two-column-right[

``` r
lines(
  density(phipsi$psi),
  col = "red",
  lwd = 2
)
```

&lt;img src="introduction_files/figure-html/unnamed-chunk-2-1.png" width="345.6" style="display: block; margin: auto;" /&gt;
]

---
## Statistical Topics of the Course

* **Smoothing:** what does `density()` do?
--

    + How do we compute nonparametric estimators?
    + How do we choose tuning parameters?
--


* **Simulation:** how do we efficiently simulate from a target distribution?
--

    + How do we assess results from Monte Carlo methods?
    + What if we cannot compute the density?
--


* **Optimization:** how do we compute the MLE?
--

    + What if we cannot compute the likelihood?
    + How to deal with very large data sets?


---
## Computational Topics of the Course

* **Implementation**: writing statistical software.
--

    + R data structures and functions
    + S3 object oriented programming
--


* **Correctness**: does the implementation do the right thing?
--

    + testing
    + debugging
    + accuracy of numerical computations
--


* **Efficiency**: minimize memory and time usage.
--

    + benchmark code for comparison
    + profile code for identifying bottlenecks
    + optimize code (Rcpp)

---
## Course Work

.pull-left[
### Assignments

- Eight assignments covering four topics
- Register in Absalon for the presentation of 
  one assignment solution. 
- Presentations are done in groups of two-three students. 
- On four Thursdays there will be presentations with discussion and feedback.
- For the exam you need to prepare four *individual* presentations, one for each topic assignment.
]

--

.pull-right[
### Examination

- Oral exam
- For each of the four topics you choose one out of two assignments to 
prepare for the exam.
- Assessment is based on your presentation *on the basis of the 
entire content of the course*.
- Get started immediately and work continuously on the assignments as the
course progresses. 
]

---
## Prerequisites in R 

Good working knowledge of:

* Data structures (vectors, lists, data frames).
--

* Control structures (loops, if-then-else).
--

* Function calling.
--

* Interactive and script usages (`source`) of R.
--

* You don't need to be an experienced programmer.

---
## Exercise

&lt;img src="PracIcon.png" width="200" style="display: block; margin: auto;" /&gt;

With `x` a vector of numbers, write code in R to compute a vector 
`y` of logicals such that `y[i]` is `TRUE` whenever `x[i] &gt; 0`. E.g. 


``` r
x
```

```
## [1] -1  0  1  2
```

``` r
y
```

```
## [1] FALSE FALSE  TRUE  TRUE
```


---
## Vectors in R

Think of a vector as a column with a number of entries.

### Atomic Vectors

All components are of the same type, e.g.

  + integers
  + numbers
  + logical values
  + character strings

--

### Lists

May contain components of different types, including components which themselves are lists. 

--

Atomic vectors and lists are important building blocks of data structures in R.

---
## Atomic Vectors and Subsetting

Example of a vector

``` r
my_vector &lt;- c(1.1, 3.2, 90, 67.7, 10)
my_vector
```

```
## [1]  1.1  3.2 90.0 67.7 10.0
```

--

You can extract components with `[]`.

``` r
my_vector[1]
```

```
## [1] 1.1
```

``` r
my_vector[c(1, 4)]
```

```
## [1]  1.1 67.7
```

``` r
my_vector[-2] # Negative indices drop corresponding components
```

```
## [1]  1.1 90.0 67.7 10.0
```
```

---
## Vectors of Class `integer`


``` r
*integer_vector &lt;- 1:10
integer_vector
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

``` r
class(integer_vector)
```

```
## [1] "integer"
```
--

This is a vector of length 10, i.e. it has 10 elements.

``` r
length(integer_vector)
```

```
## [1] 10
```

---
## Numerical Vectors

Example of a vector with non-integer values.

``` r
numeric_vector &lt;- seq(0.1, 1, by = 0.1)
numeric_vector
```

```
##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
```

``` r
class(numeric_vector)
```

```
## [1] "numeric"
```

--


``` r
typeof(numeric_vector) # Internal storage mode
```

```
## [1] "double"
```

---
## A Tricky (Non-)Integer Vector

Example of a vector with only seemingly integer values (and how to fix it).


``` r
x &lt;- c(1, 4, 7, 9)
class(x)
```

```
## [1] "numeric"
```

--


``` r
typeof(x)
```

```
## [1] "double"
```

--


``` r
x &lt;- c(1L, 4L, 7L, 9L)
class(x)
```

```
## [1] "integer"
```

---
## Comparison of Numerical Values

Values in a vector of class numeric are approximate.

``` r
numeric_vector[2:3]
```

```
## [1] 0.2 0.3
```

``` r
numeric_vector[2:3] == c(0.2, 0.3)
```

```
## [1]  TRUE FALSE
```

--

Function `all.equal` has a tolerance.

``` r
all.equal(numeric_vector[2:3], c(0.2, 0.3))
```

```
## [1] TRUE
```

---
## Precision


``` r
options(digits = 20) ## Precision of printed numbers increased
c(0.2, 0.3)
```

```
## [1] 0.2000000000000000111 0.2999999999999999889
```

``` r
numeric_vector[2:3]
```

```
## [1] 0.20000000000000001110 0.30000000000000004441
```

``` r
options(digits = 7) ## Default precision of printed numbers restored
```

--

Note that the internal storage precision is **not** changed by setting the `digits` 
option. It only affects the precision of printed numbers.

--

The differences arise because not all decimals are represented to arbitrary 
precision in the binary numeral system.


---
## Logical (Boolean) Vectors

Example of a logical vector.

``` r
logical_vector &lt;- integer_vector &gt; 4
logical_vector
```

```
##  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
```

``` r
class(logical_vector)
```

```
## [1] "logical"
```
--

How many percent (%) of the components of `integer_vector` are (strictly) larger than 4?
--


``` r
mean(integer_vector &gt; 4) * 100
```

```
## [1] 60
```

---
## Character Vectors

Example of a character vector.

``` r
character_vector &lt;- c("A", "vector", "of", "length", 6, ".")
character_vector
```

```
## [1] "A"      "vector" "of"     "length" "6"      "."
```

--


``` r
class(character_vector)
```

```
## [1] "character"
```

``` r
length(character_vector)
```

```
## [1] 6
```

--

* Observe that the number was coerced to a string.

---
## Factor (Categorical) Vectors

Example of a factor.

``` r
factor_vector &lt;- factor(c(
  "m", "m", "f", "m", "f",
  "m", "f", "f", "f", "m"
))
factor_vector
```

```
##  [1] m m f m f m f f f m
## Levels: f m
```

``` r
class(factor_vector)
```

```
## [1] "factor"
```

--

* Might look like a character vector but based on an integer vector.
--


``` r
typeof(factor_vector)
```

```
## [1] "integer"
```

--
* Can only take a fixed set of values (default: values present in data).
--

* Possibility of reordering levels convenient e.g. for plots.

---
## Date Vectors

Example of a date vector.


``` r
date_vector &lt;- seq(Sys.Date(), length.out = 4, by = "quarter")
date_vector
```

```
## [1] "2024-08-16" "2024-11-16" "2025-02-16" "2025-05-16"
```

``` r
class(date_vector)
```

```
## [1] "Date"
```

--

* Date vectors might also look like character vectors, but they are based on numeric vectors.


---
## Lists

A list with named elements.

.pull-left[

``` r
my_list &lt;- list(
  my_integers = integer_vector,
  my_factor = factor_vector,
  my_logicals = logical_vector,
  my_dates = date_vector
)

my_list
```
]

.pull-right[

```
## $my_integers
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## $my_factor
##  [1] m m f m f m f f f m
## Levels: f m
## 
## $my_logicals
##  [1] FALSE FALSE FALSE FALSE  TRUE
##  [6]  TRUE  TRUE  TRUE  TRUE  TRUE
## 
## $my_dates
## [1] "2024-08-16" "2024-11-16"
## [3] "2025-02-16" "2025-05-16"
```
]

---
## Subsetting Lists

Example of a sublist.

``` r
my_first_sublist &lt;- my_list[1:3]
my_first_sublist
```

```
## $my_integers
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## $my_factor
##  [1] m m f m f m f f f m
## Levels: f m
## 
## $my_logicals
##  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
```
--


``` r
class(my_first_sublist)
```

```
## [1] "list"
```

---
## Subsetting lists

Example of another sublist.

``` r
my_second_sublist &lt;- my_list[4]
my_second_sublist
```

```
## $my_dates
## [1] "2024-08-16" "2024-11-16" "2025-02-16" "2025-05-16"
```
--


``` r
class(my_second_sublist)
```

```
## [1] "list"
```

---
## Subsetting Lists

Extracting components from a list.


``` r
dates_from_list &lt;- my_list$my_dates
dates_from_list
```

```
## [1] "2024-08-16" "2024-11-16" "2025-02-16" "2025-05-16"
```
--


``` r
class(dates_from_list)
```

```
## [1] "Date"
```
--

The original date vector and the one extracted from the list are identical:

``` r
identical(date_vector, dates_from_list)
```

```
## [1] TRUE
```

---
## Exercise

&lt;img src="PracIcon.png" width="200" style="display: block; margin: auto;" /&gt;

Run the following code and explain the differences/similarities


``` r
xl &lt;- list(x = c(-1, 0, 1, 2))
xl[1]
xl[[1]]
xl$x
```

---
## Data Frames

Example of a data frame.


``` r
my_data_frame &lt;- as.data.frame(my_first_sublist)
my_data_frame
```

```
##    my_integers my_factor my_logicals
## 1            1         m       FALSE
## 2            2         m       FALSE
## 3            3         f       FALSE
## 4            4         m       FALSE
## 5            5         f        TRUE
## 6            6         m        TRUE
## 7            7         f        TRUE
## 8            8         f        TRUE
## 9            9         f        TRUE
## 10          10         m        TRUE
```
--

**Question:** Why does `as.data.frame(my_list)` produce an error? 


---
## Subsetting data frames

Extracting one column from a data frame by name.

``` r
my_data_frame$my_integers
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```
--

Extracting one column from a data frame using that it is a list.

``` r
my_data_frame[[1]]
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```
--

Extracting one column from a data frame using data frame subsetting.

``` r
my_data_frame[, 1]
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

---
## Subsetting data frames

You can subset data frames using brackets


``` r
my_data_frame[5, 1]
```

```
## [1] 5
```

--

... and you can assign values to entries using brackets such as 


``` r
my_data_frame[5, 1] &lt;- NA
my_data_frame[1, 3] &lt;- NA
```

---
## Functions

We introduced missing values in our data frame above. Suppose we want to 
impute a value whenever it's missing.
--


``` r
within(my_data_frame, my_integers &lt;- ifelse(is.na(my_integers), 0, my_integers))
```

```
##    my_integers my_factor my_logicals
## 1            1         m          NA
## 2            2         m       FALSE
## 3            3         f       FALSE
## 4            4         m       FALSE
## 5            0         f        TRUE
## 6            6         m        TRUE
## 7            7         f        TRUE
## 8            8         f        TRUE
## 9            9         f        TRUE
## 10          10         m        TRUE
```

However, this is a bit cumbersume to copy-paste around, and it's 
not totally clear what this code does. Lets write a function with a good 
name.
--


``` r
impute_missing &lt;- function(x) {
  ifelse(is.na(x), 0, x)
}
```

---
## Functions


``` r
within(my_data_frame, my_integers &lt;- impute_missing(my_integers))
```

```
##    my_integers my_factor my_logicals
## 1            1         m          NA
## 2            2         m       FALSE
## 3            3         f       FALSE
## 4            4         m       FALSE
## 5            0         f        TRUE
## 6            6         m        TRUE
## 7            7         f        TRUE
## 8            8         f        TRUE
## 9            9         f        TRUE
## 10          10         m        TRUE
```

---

## Exercise

&lt;img src="PracIcon.png" width="200" style="display: block; margin: auto;" /&gt;

Write a function, `is_pos`, which takes a vector `x` as argument and returns a
vector of logicals whose i-th entry is `TRUE` whenever `x[i] &gt; 0`. E.g. 


``` r
is_pos(c(-1, 0, 1, 2))
```

```
## [1] FALSE FALSE  TRUE  TRUE
```



---
## Functions

What happens if we apply the `impute_missing` to other columns?


``` r
impute_missing
```

```
## function(x) {
##   ifelse(is.na(x), 0, x)
## }
```

--


``` r
within(my_data_frame, my_logicals &lt;- impute_missing(my_logicals))
```

```
##    my_integers my_factor my_logicals
## 1            1         m           0
## 2            2         m           0
## 3            3         f           0
## 4            4         m           0
## 5           NA         f           1
## 6            6         m           1
## 7            7         f           1
## 8            8         f           1
## 9            9         f           1
## 10          10         m           1
```

---

## Better impute function


``` r
impute_missing &lt;- function(x, value = 0) {
  ifelse(is.na(x), value, x)
}
```
--



``` r
within(my_data_frame, {
  my_integers &lt;- impute_missing(my_integers)
  my_logicals &lt;- impute_missing(my_logicals, value = FALSE)
})
```

```
##    my_integers my_factor my_logicals
## 1            1         m       FALSE
## 2            2         m       FALSE
## 3            3         f       FALSE
## 4            4         m       FALSE
## 5            0         f        TRUE
## 6            6         m        TRUE
## 7            7         f        TRUE
## 8            8         f        TRUE
## 9            9         f        TRUE
## 10          10         m        TRUE
```

---
## R programming 

R functions are fundamental. They don't do anything before they are called and the call is evaluated. 
--


An R function takes a number of *arguments*, and when a function call is evaluated it computes a *return value*.

--

An R program consists of a hierarchy of function calls. When the program is executed, function calls are evaluated and 
replaced by their return values. 

--

Implementations of R functions are collected into source files, which can be organized into R packages.

--

An R script (or R Markdown document) is a collection of R function calls, which, when evaluated, 
compute a desired result. 

--

R programming includes activities at many different levels of sophistication and abstraction.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:10",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
