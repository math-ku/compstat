---
title: "Rcpp"
---

{{< include _common.qmd >}}

```{r setup, include=FALSE}
library(patchwork)

old_options <- options(digits = 4)
```

```{Rcpp source-rcpp, ref.label=knitr::all_rcpp_labels(), include=FALSE}

```

```{Rcpp namespace, include = FALSE}
#include <Rcpp.h>
using namespace Rcpp;
```

## Last Time: Stochastic Gradient Descent

\begin{algorithm}[H]
  \caption{Stochastic gradient descent (with mini-batches)}
  \KwData{Initial step size $t_0 > 0$}
  \For{$k = 1,2,\dots$}{
    $A_k \gets$ batch of data\;

    $t_k \gets$ new, smaller, step size\;

    $x \gets x - t_k \sum_{i \in A_k} \nabla f(x_i)$\;
    \If{converged}{
      \Return{$x$}
    }
  }
\end{algorithm}

\medskip\pause

We mentioned that R is ill-suited for this type of algorithm. Today, we will
learn how to fix this through C++.

## Today

### C++

Why do we want to use C++?

\medskip\pause

What is **compiled** code?

. . .

### Rcpp

We learn how to connect R and C++ using the Rcpp package.

## Why R?

:::: {.columns}

::: {.column width="30%"}

Why are we even using R?

\bigskip

![](../images/r-logo.svg)

:::

::: {.column width="60%"}

\pause

Because R lets us

- work interactively,
- explore and visualize data via a rich toolset,\pause
- easily retrieve or generate data,\pause
- summarize and report (via RMarkdown/Quarto), and\pause
- make use of a comprehensive ecosystem of packages.

:::

::::

## Why _Not_ R?

R is often slow because it is an **interpreted** language.

. . .

:::: {.columns}

::: {.column width="47%"}

### Interpreted Languages

<!-- TODO: Add flow chart to describe interpreted languages -->

Execution of code happens line by line.

\medskip\pause

Many functions are written in C, but you still have to call them from R.

\medskip\pause

**Examples:** R, Python, Matlab, Javascript.

:::

. . .

::: {.column width="47%"}

### Compiled Languages

Code is translated into machine code before execution.

\medskip\pause

**Examples:** C, C++, Fortran, Java

:::

::::

##

![Compiled vs interpreted languages according to DALL-E 2 in 2024.](../images/chatgpt-compiled-interpreted.png){width=55%}

##

![Compiled vs interpreted languages according to ChatGPT in 2025.](../images/chatgpt-compiled-interpreted-2025.png){width=75%}

##

\begin{figure}
  \centering
  \begin{tikzpicture}[
      node distance=0.5cm and 1cm,
      process/.style={rectangle, draw, rounded corners, minimum width=2.2cm, minimum height=1cm},
      arrow/.style={->, thick}
    ]

    % Interpreted pipeline
    \node[process, fill=yellow!10] (src) {Source code};
    \node[diamond, draw, fill=green!15, above=of src] (user) {User};
    \node[process, fill=blue!10, right=of src] (interp) {Interpreter};
    \node[process, fill=red!15, right=of interp] (bin) {Machine code};
    \node[circle, draw, fill=gray!15, right=of bin] (cpu) {CPU};

    \draw[arrow] (src) -- (interp);
    \draw[arrow] (user) -- (src);
    \draw[arrow] (interp) -- (bin);
    \draw[arrow] (bin) -- (cpu);
  \end{tikzpicture}
  \caption{Interpreted languages (R, Python)}
\end{figure}

\pause

\begin{figure}
  \centering
  \begin{tikzpicture}[
      node distance=0.5cm and 1cm,
      process/.style={rectangle, draw, rounded corners, minimum width=2.2cm, minimum height=1cm, align=center},
      arrow/.style={->, thick}
    ]
    % Compiled pipeline
    \node[process, fill=yellow!10] (src) {Source code};
    \node[process, fill=blue!10, right=of src] (comp) {Compiler};
    \node[process, fill=red!15, right=of comp] (bin) {Machine code};
    \node[circle, draw, fill=gray!15, right=of bin] (cpu) {CPU};
    \node[diamond, draw, fill=green!15, above=of bin] (user) {User};

    \draw[dashed,arrow] (src) -- (comp);
    \draw[dashed,arrow] (comp) -- (bin);
    \draw[arrow] (user) -- (bin);
    \draw[arrow] (bin) -- (cpu);
  \end{tikzpicture}
  \caption{Compiled Languages (C++, Fortran, Rust)}
\end{figure}


## C++ Code

Here's a small program in C++.

```cpp
int
add(int a, int b)
{
  return a + b;
}

int
main()
{
  std::cout << add(2, 3) << std::endl;
  return 0;
}
```

## Assembly Representation

In assembly (human-readable machine) code, the code on the previous slide might look like this:

```assembly
0000000000401130 <main>:
  401130:       55                      push   %rbp
  401131:       48 89 e5                mov    %rsp,%rbp
  401134:       48 83 ec 10             sub    $0x10,%rsp
  ···           ···                     ···    ···
  401149:       8b 45 f8                mov    -0x8(%rbp),%eax
  401165:       c9                      leaveq
  401166:       c3                      retq
```

. . .

### Binary Representation

In the end, this will be converted in binary (0s and 1s).

## Why C++?

C++ generates performant machine code: you no longer have to be scared of for loops.

\medskip\pause

Compilation catches bugs early.

\medskip

. . .

:::: {.columns align="center"}

::: {.column width="47%"}

![](../images/compiling.png){width=100%}

:::

::: {.column width="47%" align="center"}

### Why _Not_ C++?

Compiling adds overhead and complicates debugging.

\medskip\pause

Distributing code is more involved.

:::

::::

## Bridging R and C++ with Rcpp

R is actually built partially in compiled languages (C, Fortran).

\medskip\pause

But, writing your own C/C++ code and connecting it to R has
historically been painful.

\medskip\pause

This has changed with the Rcpp package.

## The Sum Function in C++

```{Rcpp rcpp-sum, eval = FALSE}
// [[Rcpp::export]]
double
sum_cpp(Rcpp::NumericVector x) {
  double total = 0;
  const int n = x.size();

  for (int i = 0; i < n; ++i) {
    total += x[i];
  }

  return total;
}
```

## R Interface of Rcpp

- Provides collection of classes to represent R objects
  - `Rcpp::NumericVector`
  - `Rcpp::DataFrame`
- Adds a number of functions, often vectorized, to manipulate these objects
  - `Rcpp::sum()`
  - `Rcpp::runif()`
- Seamless transformation between R and C++ objects.

## Installing Rcpp

### Linux

Depends on distro, but on Ubuntu call this:

```bash
sudo apt install r-base-dev
```

. . .

### OSX

You need Xcode. Open up a terminal and call this:

```sh
xcode-select --install
```

. . .

### Windows

Install [Rtools](https://cran.r-project.org/bin/windows/Rtools/).

## Side-By-Side Comparison

:::: {.columns}

::: {.column width="40%"}

### R

```{r}
library(Rcpp)

sum_r <- function(x) {
  total <- 0

  for (i in seq_along(x)) {
    total <- total + x[i]
  }

  total
}
```

:::

. . .

::: {.column width="54%"}

### C++

```cpp
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double
sum_cpp(NumericVector x)
{
  double total = 0;

  for (int i = 0; i < x.size(); ++i)
    total += x[i];

  return total;
}
```

:::

::::

# Writing Code in Rcpp

## Return and Argument Types

C++ is **strongly typed**: you need to specify types for 
both return value and arguments.

. . .

```cpp
double   // Return type: double
f(int x) // Argument type: int
{
  return x / 3;
}
```

. . .

If your function returns nothing, use `void`:

```cpp
void
f()
{
  Rcpp::cout << "Hello world" << std::endl;
}
```

## Syntax

### Assignment

You assign values using `=` (not `<-`, as in R).

. . .

### Statements

Statements end with a semicolon (`;`). A new line is not enough!

. . .

### Explicit Return

You need to use `return` to return a value.

:::: {.columns}

::: {.column width="47%"}

```r
f <- function(x) {
  y <- x + 1
  y
}
```

:::

::: {.column width="47%"}

```cpp
int
f(int x)
{
  int y = x + 1;
  return y;
}
```

:::

::::

## Zero-Based Indexing

In C++, vector and array indices start at 0 (not 1)!

\medskip\pause

Don't do this!

```cpp
void
ooops(Rcpp::NumericVector x)
{
  for (int i = 0; i <= x.size(); ++i) {
    x[i] = x[i] / 5;
  }
}
```

. . .

Will look at one element past the end of the vector!

## Declaration Order Matters

This will not compile:\footnote{But would work just fine in R.}

```cpp
double
f(double x)
{
  return g(x) + 1;
}

double
g(double x)
{
  return x * 2;
}
```

. . .

You need to declare `g()` before `f()`.

## References

In C++, you can explicitly pass arguments by reference using `&`.

```cpp
void
f(double& x)
{
  x = x + 1;
}
```

. . .

```cpp
double
g()
{
  double x = 2;
  f(x);
  return x; // returns 3
}
```

## Pointers

You can also use pointers, but you don't need them with Rcpp
and can be confusing and dangerous.

```cpp
void
f(double x)
{
  double* p = &x;
  *p = *p + 1;

  return;
}
```

## In-Place Modification

Unlike R, C++ functions can modify their arguments in place.

```cpp
void
f(int& x)
{
  x += 1; // identical to x = x + 1;
}

int
g()
{
  int x = 2;
  f(x);
  return x; // returns 3
}
```

```{Rcpp rcpp-sum-ref, eval = FALSE, echo=FALSE}
// [[Rcpp::export]]
double
sum_cpp_ref(Rcpp::NumericVector& x) {
  double total = 0.0;
  const int n = x.size();

  for (int i = 0; i < n; ++i) {
    total += x[i];
  }

  return total;
}
```

## Classes and Objects

C++ is an object-oriented programming language.

```cpp
class Point
{
public:
  double x;
  double y;
}
```

. . .

```cpp
Point
create_point(double x, double y)
{
  Point p;
  p.x = x;
  p.y = y;

  return p;
}
```

## Methods in C++

In C++, methods belong to classes.

```cpp
class Point
{
public:
  double x;
  double y;

  double distance_from_origin() { return std::sqrt(x * x + y * y); }
};
```

. . .

Methods are called using the `.` operator.

```cpp
double
distance(Point p)
{
  return p.distance_from_origin();
}
```

## C++ is Not a Functional Programming Language

But it has elements of it. 

\medskip\pause

You can, for instance, pass functions as arguments.

```cpp
int
add(int a, int b)
{
  return a + b;
}

int
compute(int x, int y, int (*func)(int, int))
{
  return func(x, y);
}
```

## Function Arguments

In R, the same function can take different types of arguments.

\medskip\pause

This works differently in C++:

```cpp
double
f(int x)
{
  return x + 1;
}

void
main()
{
  f(3);   // OK (an integer, result is 4)
  f(2.5); // Look out! (Compiles, but `x` -> 2, result is 3)
  f("2"); // Error! (Cannot convert string to int.)
}
```

## Function Overloading

Instead, you can define multiple functions with the same name but different
argument types:


```cpp
double
f(double x)
{
  return x + 1;
}

int
f(int x)
{
  return x + 1;
}
```

## Constants

In C++, we can use `const` to declare constants.

```cpp
const double pi = 3.14159;
pi = 3.14; // Error!
```

. . .

After declaration, the variable cannot be modified.

\medskip\pause

Marginal performance improvements, but signals intent and can prevent bugs.

## Including C++ Code in R

```{r}
library(Rcpp)
```

. . .

The C++ code can be passed directly to the `cppFunction()` as a text string for
compilation and setting up an R interface.

```{r}
cppFunction(
  "int one() {return 1;}"
)
```

. . .

And then the function can be called from R.

```{r}
one()
```

## Source Files

But it's better to use `.cpp` files (for instance in the `src/` folder) and call
`sourceCpp()` (or RStudio's UI tool).

\medskip\pause

In `R/my_r_experiment.R` (or similar), call

```r
sourceCpp(here::here("src", "my_cpp_functions.cpp"))
```

```
my_project/
├── scripts/
│   └── my_r_experiment.R    # R script
├── src/
│   └── my_cpp_functions.cpp # Source for C++ functions
└── my_rproject.Rproj        # RStudio project file
```

## Rcpp Syntax

Each file should start with

```cpp
#include <Rcpp.h>
```

. . .

Before each function you want to export to R, add the comment

```cpp
// [[Rcpp::export]]
```

## Sum Functions

Let's see if we can beat R's own `sum()` (See
[here](https://github.com/wch/r-source/blob/3b69aff4083ee81d6c4fe7177eb2b2a2ca41a240/src/main/summary.c#L152)
for the implementation.)

```{r bench-sum, cache = TRUE}
#| fig-width: 5
#| fig-height: 2.2
x <- runif(1e5)
bench::mark(sum(x), sum_cpp(x), sum_r(x)) |>
  plot()
```

## References in Rcpp

You might think that this would create a copy
of the R input vector.

```cpp
// [[Rcpp::export]]
double
sum_cpp_ref(Rcpp::NumericVector x)
{
  return Rcpp::sum(x);
}
```

. . .

But no, `Rcpp::NumericalVector` is a reference to the R object.

## Pitfall: Modifying R Objects

```{Rcpp rcpp-uhoh, eval = FALSE}
// [[Rcpp::export]]
void
uh_oh(Rcpp::NumericVector x)
{
  x = x + 1.0;
}
```

. . .

```{r uh-oh}
x <- 1.5:4.5
uh_oh(x)
x
```

. . .

The input vector `x` has been modified in place! You can use `Rcpp::clone()`
to avoid this.

## `Const` References

If you don't want to modify the input, you can pass by const reference.

. . .

```{Rcpp rcpp-sum-constref, eval = FALSE}
// [[Rcpp::export]]
double
sum_cpp_const_ref(const Rcpp::NumericVector& x) {
  double total = 0.0;
  const int n = x.size();

  for (int i = 0; i < n; ++i) {
    total += x[i];
  }

  return total;
}
```

In C++, this can make a big difference, but with Rcpp, it makes no difference.

## Printing

Printing to the R console can be done using `Rcpp::Rcout`.

```{Rcpp rcpp-print, eval = FALSE}
// [[Rcpp::export]]
void
print_cpp(const Rcpp::NumericVector& x) {
  Rcpp::Rcout << "x = " << x << std::endl;
}
```

. . .

```{r}
print_cpp(1:5)
```

## Errors and Warnings

You can signal errors and warnings using `Rcpp::stop()` and `Rcpp::warning()`.

```{Rcpp rcpp-error, eval = FALSE}
// [[Rcpp::export]]
double
safe_log(double x) {
  if (x <= 0) {
    Rcpp::stop("x must be positive");
  }
  return std::log(x);
}
```

## Sugar

Rcpp contains a wealth of syntactic **sugar**, such
as vectorized functions.

```{Rcpp rcpp-sum-sugar, eval = FALSE}
// [[Rcpp::export]]
double sum_cpp_sugar(const Rcpp::NumericVector& x) {
  return Rcpp::sum(x);
}
```

## Premature Optimization

Premature optimization is especially useless with C++ since
the compiler will often optimize the code for you anyway.

\medskip\pause

What you see in the source code is **not** what you get.

\medskip\pause

Copies and temporaries are often optimized away.

## Example: Von Mises Rejection Sampling

### R Version

```{r vM-rejection, cache = TRUE}
rvonmises <- function(n, kappa) {
  y <- numeric(n)
  for (i in 1:n) {
    reject <- TRUE
    while (reject) {
      y0 <- runif(1, -pi, pi)
      u <- runif(1)
      reject <- u > exp(kappa * (cos(y0) - 1))
    }
    y[i] <- y0
  }
  y
}
```

##

### Rcpp Version

```{Rcpp vMsim-cpp, eval = FALSE}
// [[Rcpp::export]]
NumericVector
rvonmises_cpp(const int n, const double kappa)
{
  NumericVector y(n);
  int i = 0;

  while (i < n) {
    double y0 = R::runif(-M_PI, M_PI);
    bool accept = R::runif(0, 1) <= exp(kappa * (cos(y0) - 1));
    if (accept) {
      y[i] = y0;
      i++;
    }
  }
  return y;
}
```

##

```{r vMsim-cpp-runtime, dependson=c("vMsim-cpp", "vM-rejection"), echo = FALSE}
#| fig-width: 5
#| fig-caption: "Benchmark of R and Rcpp implementations of the von Mises rejection sampler."
bench::mark(
  rvonmises(1000, kappa = 5),
  rvonmises_cpp(1000, kappa = 5),
  check = FALSE
) |>
  plot()
```

## The Standard Template Library (STL)

A library of generic algorithms, data structures, and iterators for C++.

\medskip\pause

Accessed via the `std` namespace.

\medskip\pause

Provides a number of useful functions for working with vectors and other
containers.

. . .

### Efficiently Growing Vectors

Unlike R and Rcpp vector, `std::vector()` grows efficiently.

```cpp
std::vector<int> x;

for (int i = 0; i < 10; ++i) {
  x.emplace_back(i);
}
```

## Linear Algebra with RcppArmadillo

Armadillo is a user-friendly C++ library for linear algebra.

```cpp
#include <RcppArmadillo.h>

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat
armaMatMul(const arma::mat& A, const arma::mat& B)
{
  return A * B;
}
```

. . .

Intuitive syntax, depends on BLAS and LAPACK.

## Linear Algebra with RcppEigen

Eigen is another popular C++ library for linear algebra.

```cpp
#include <RcppEigen.h>

// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::export]]
Eigen::MatrixXd
eigenMatMul(const Eigen::MatrixXd& A, const Eigen::MatrixXd& B)
{
  return A * B;
}
```

. . .

More low-level than Armadillo, but does not depend on BLAS/LAPACK.

## Parallelization

Parallelization in R comes with overhead. The situation in C++ is better.

\medskip\pause

To main ways to parallelize C++ code in R are OpenMP and the
[RcppParallel](https://rcppcore.github.io/RcppParallel/) package.

```cpp
#include <RcppParallel.h>
using namespace Rcpp;

// [[Rcpp::depends(RcppParallel)]]
// [[Rcpp::export]]
double
parallel_function(const Rcpp::NumericVector& x)
{
  // Your parallel code here
}
```

. . .

We won't cover the details here, but expect much better leverage than
using R's parallelization tools.

## Packages

Like tests, Rcpp code works best in packages. 

\medskip\pause

We will cover this in our final lecture.

\medskip\pause

Not as complicated as you might think!

:::: {.columns align="center"}

::: {.column width="62%"}

. . .

### R Packages

Great book to get started; free and available online at <https://r-pkgs.org>.

:::

::: {.column width="25%"}

![](../images/r-pkgs.png){width=100%}

:::

::::

## The cpp11 Package

Nowadays, you can also use the [cpp11](https://cpp11.r-lib.org/) package, which works
similarly to Rcpp but is more lightweight.

\medskip\pause

Won't cover it here, but has some advantages and disadvantages compared to Rcpp.

. . .

:::: {.columns}

::: {.column width="47%"}

### Advantages

- Compiles faster
- Grows vectors efficiently
- Enforces copy-on-write semantics (like R)

:::

. . .

::: {.column width="47%"}

### Disadvantages

- Smaller ecosystem
- Fewer built-in functions (sugar)
- No (stable) Armadillo or Eigen bindings

:::

::::

## Getting Help

- [The many official vignettes](https://cran.r-project.org/web/packages/Rcpp/index.html)\pause
- [Rcpp For Everyone](https://teuder.github.io/rcpp4everyone_en/) by Masaki E. Tsuda\pause
- [Rcpp Gallery](https://gallery.rcpp.org/)\pause
- [The unofficial Rcpp API documentation](https://thecoatlessprofessor.com/programming/cpp/unofficial-rcpp-api-documentation/)

## Exercise

1. Implement a function using Rcpp that computes the standard deviation of a
   (numeric) vector. Benchmark against `sd()`.\footnote{Don't use `Rcpp::sd()`, please!}\pause
2. Test your function against R's `sd()` function to make sure it works correctly.\pause
3. Benchmark your function against R's `sd()` function to see if it is faster.
4. Handle cases when the input vector is of length 0 or 1.

```{Rcpp rcpp-sd, eval = FALSE, echo = FALSE}
// [[Rcpp::export]]
double
cpp_sd(NumericVector x) {
  double out = 0.0;
  double x_mean = 0.0;

  int n = x.size();

  for (int i = 0; i < n; ++i) {
    x_mean += x[i] / n;
  }

  for (int i = 0; i < n; ++i) {
     out += std::pow(x[i] - x_mean, 2);
  }

  return std::sqrt(out / (n - 1));
}
```

## Summary

R is an interpreted language, which makes it easy to use but often slow.

\medskip\pause

You can use C++ to speed up your code, and it is not as hard as you might think.

\medskip\pause

But there are pitfalls, so be careful!

\medskip\pause

Debugging C++ code is tricky and failures can crash R.

## Course Evaluations

The course evaluations are open!

\medskip

Please take a few minutes to fill them out. Your feedback is valuable!

## Next Two Lectures

### Variations on Stochastic Gradient Descent

We expand on the stochastic gradient descent algorithm, looking at
momentum and adaptive step sizes.

. . .

### R Packages and Wrap-up (Final Lecture)

We learn how to set up R packages, which is the best way to
distribute R and Rcpp code.
