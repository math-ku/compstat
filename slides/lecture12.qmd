---
title: "Rcpp"
---

{{< include _common.qmd >}}

```{r setup, include=FALSE}
library(patchwork)

old_options <- options(digits = 4)
```

```{Rcpp source-rcpp, ref.label=knitr::all_rcpp_labels(), include=FALSE}

```

```{Rcpp namespace, include = FALSE}
#include <Rcpp.h>
using namespace Rcpp;
```

## Last Time

Last time, we covered stochastic gradient descent.

\medskip\pause

\begin{algorithm}[H]
  \caption{Stochastic gradient descent (with mini-batches)}
  \KwData{Initial step size $t_0 > 0$}
  \For{$k = 1,2,\dots$}{
    $A_k \gets$ batch of data\;

    $t_k \gets$ new, smaller, step size\;

    $x \gets x - t_k \sum_{i \in A_k} \nabla f(x_i)$\;
    \If{converged}{
      \Return{$x$}
    }
  }
\end{algorithm}

\medskip\pause

We mentioned that R is ill-suited for this type of algorithm. Today, we will
learn how to fix this through C++.

## Today

### C++

Why do we want to use C++?

\medskip\pause

What is **compiled** code?

. . .

### Rcpp

We learn how to connect R and C++ using the Rcpp package.

## Why R?

:::: {.columns}

::: {.column width="30%"}

Why are we even using R?

\bigskip

![](../images/r-logo.svg)

:::

. . .

::: {.column width="60%"}

Because R lets us

- work interactively,
- explore and visualize data via a rich toolset,\pause
- easily retrieve or generate data,\pause
- summarize and report (via RMarkdown/Quarto), and\pause
- make use of a comprehensive ecosystem of packages.

:::

::::

## Why _Not_ R?

R is often slow because it is an **interpreted** language.

. . .

:::: {.columns}

::: {.column width="47%"}

### Interpreted Languages

<!-- TODO: Add flow chart to describe interpreted languages -->

Execution of code happens line by line.

\medskip\pause

Many functions are written in C, but you still have to call them from R.

\medskip\pause

**Examples:** R, Python, Matlab, Javascript.

:::

. . .

::: {.column width="47%"}

### Compiled Languages

Code is translated into machine code before execution.

\medskip\pause

**Examples:** C, C++, Fortran, Java

:::

::::

## 

![Compiled vs interpreted languages according to DALL-E 2.](../images/chatgpt-compiled-interpreted.png){width=55%}

## C++ Code

Here's a small program in C++.

```cpp
int add(int a, int b) { return a + b; }

int main() {
  std::cout << add(2, 3) << std::endl;
  return 0;
}
```

## Assembly Representation

In machine code, the code on the previous slide might look like this:

```assembly
0000000000401130 <main>:
  401130:       55                      push   %rbp
  401131:       48 89 e5                mov    %rsp,%rbp
  401134:       48 83 ec 10             sub    $0x10,%rsp
  ···           ···                     ···    ···
  401149:       8b 45 f8                mov    -0x8(%rbp),%eax
  401165:       c9                      leaveq
  401166:       c3                      retq
```

. . .

### Binary Representation

In the end, this will be represented in binary (1s and 0s).

## Why C++?

C++ generates machine code: no longer have to be scared of loops!

\medskip\pause

Pass by reference: no need to copy large objects.

\medskip\pause

Access to external C++ libraries

\medskip\pause

Wrap and reuse C++ code with other languages

\medskip\pause

Compilation catches bugs early.

:::: {.columns}

::: {.column width="47%"}

### Why _Not_ C++?

Compiling adds overhead.

\medskip\pause

Debugging is more complicated.

\medskip\pause

Distributing code is more involved.


:::

::: {.column width="47%"}

![](../images/compiling.png){width=80%}

:::

::::

## R Can Be Extended

But we can extend R by coupling it to a compiled language, like

- C,
- C++,
- Fortran, and
- Java.

. . .

### Problem {.alert}

Doing so has historically been **tedious** and **error-prone**.

. . .

## Basic C++ Version of `sum()`

```{c sum-c, eval=FALSE}
// foo.c
#include <R.h>
#include <Rinternals.h>

extern "C++"
{
  SEXP sum_c(SEXP x)
  {
    x = PROTECT(coerceVector(x, REALSXP));
    SEXP s = PROTECT(allocVector(REALSXP, 1));
    double* x_ref = REAL(x);
    double* s_ref = REAL(s);

    for (int i = 0; i < length(x); i++)
      s_ref[0] += x_ref[i];

    UNPROTECT(2);

    return s;
  }
}
```

## C++ Example (Continued)

Next, we need to compile this into a binary file by calling:

```{sh shlib, eval = FALSE}
R CMD SHLIB foo.c
```

. . .

Then, in R, we would call this:

```{r foo-so, eval = FALSE}
dyn.load("foo.so") # or `foo.dll` if on Windows
```

. . .

Finally, access function by calling this:

```{r foo-r, eval = FALSE}
x <- c(1.0, 1.5, -0.2, 0.1, 0.0)
.Call("sum_c", x = x)
```

```{r, echo = FALSE}
sum(c(1.0, 1.5, -0.2, 0.1, 0.0))
```

## Rcpp

Rcpp simplifies this process **considerably**.

```{Rcpp rcpp-sum, eval = FALSE}
// [[Rcpp::export]]
double sum_cpp(Rcpp::NumericVector x) {
  double total = 0;
  const int n = x.size();

  for (int i = 0; i < n; ++i) {
    total += x[i];
  }

  return total;
}
```

. . .

### Exporting C++ Functions

Automatizes the process of compiling, linking, and exporting.

. . .

## R Interface of Rcpp

- Provides collection of classes to represent R objects
  - `Rcpp::NumericalVector`
  - `Rcpp::DataFrame`
- Adds a number of functions, often vectorized, to manipulate these objects
  - `Rcpp::sum()`
  - `Rcpp::runif()`
- Seamless transformation between R and C++ objects.

## Installing Rcpp

### Linux

Depends on distro, but on Ubuntu call this:

```bash
sudo apt install r-base-dev
```

. . .

### OSX

You need Xcode. Open up a terminal and call this:

```sh
xcode-select --install
```

. . .

### Windows

Install [Rtools](https://cran.r-project.org/bin/windows/Rtools/).

## Side-By-Side Comparison

:::: {.columns}

::: {.column width="44%"}

### R

```{r}
library(Rcpp)

sum_r <- function(x) {
  total <- 0

  for (i in seq_along(x)) {
    total <- total + x[i]
  }

  total
}
```

:::

. . .

::: {.column width="50%"}

### C++

```cpp
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double sum_cpp(NumericVector x) {
  double total = 0;
  const int n = x.size();

  for (int i = 0; i < n; ++i) {
    total += x[i];
  }

  return total;
}
```

:::

::::

## Writing Code in R and Rcpp

### Notable Differences

- **Vectors are indexed from 0**
- Statements end with a semicolon (**`;`**)
- The assignment operator is **`=`**
- Input and output types need to be declared
- Class methods have a different syntax (e.g. `x.size()` not `size(x)`)
- An explicit `return` statement is required to return a value
- For loops have a different syntax: `for (<init>; <check>; <increment>)`
- You don't assign to create functions.

. . .

### Similarities

- Rcpp classes, like `NumericVector` and `List`, unify data structures in R and
  C++
- Rcpp implements vectorized arithmetic (as in R)
- Rcpp implements a long list of vectorized R-like functions

## Including C++ Code in R

```{r}
library(Rcpp)
```

. . .

The C++ code can be passed directly to the `cppFunction()` as a text string for
compilation and setting up an R interface.

```{r}
cppFunction(
  "int one() {return 1;}"
)
```

. . .

And then the function can be called from R.

```{r}
one()
```

## Source Files

Better to put C++ code in an `.cpp` file (for instance in `src/` folder) and use
`sourceCpp()` (or RStudio's UI tool) to compile the code and set up the R
interface.

\medskip\pause

In `R/my_r_experiment.R` (or similar), call

```r
sourceCpp(here::here("src", "my_cpp_functions.cpp"))
```

```
my_project/
├── scripts/
│   └── my_r_experiment.R    # R script
├── src/
│   └── my_cpp_functions.cpp # Source for C++ functions
└── my_rproject.Rproj        # RStudio project file
```

. . .

Each file should start with

```cpp
#include <Rcpp.h>
```

## Sum Functions

Let's see if we can beat R's own `sum()` (See
[here](https://github.com/wch/r-source/blob/3b69aff4083ee81d6c4fe7177eb2b2a2ca41a240/src/main/summary.c#L152)
for the implementation.)

```{r bench-sum, cache = TRUE}
#| fig-width: 5
#| fig-height: 2.2
x <- runif(1e5)
bench::mark(sum(x), sum_cpp(x), sum_r(x)) |>
  plot()
```

## Constants

In C++, we can use `const` to declare constants.

```cpp
const double pi = 3.14159;
pi = 3.14; // Error!
```

. . .

After declaration, the variable cannot be modified.

\medskip\pause

Marginal performance improvements, but also helps catch bugs.


. . .

### Const Correctness

Enforce immutability wherever appropriate.


## Passing by Reference

Useful to avoid copying large objects or when we want to modify the input.

\medskip\pause

Post-fix `&` to the type.

```{Rcpp rcpp-sum-ref, eval = FALSE}
// [[Rcpp::export]]
double sum_cpp_ref(Rcpp::NumericVector& x) {
  double total = 0.0;
  const int n = x.size();

  for (int i = 0; i < n; ++i) {
    total += x[i];
  }

  return total;
}
```

## Rcpp Objects Reference R Objects

- Modifing the Rcpp object modifies the original object.
- Little point in using `&` in **exported** functions.

## `Const` References

If you don't want to modify the input, you can pass by const reference.

. . .

```{Rcpp rcpp-sum-constref, eval = FALSE}
// [[Rcpp::export]]
double sum_cpp_const_ref(const Rcpp::NumericVector& x) {
  double total = 0.0;
  const int n = x.size();

  for (int i = 0; i < n; ++i) {
    total += x[i];
  }

  return total;
}
```

In C++, this can make a big difference, but with Rcpp, it makes no difference.

## Value of Constant References

```{Rcpp constref-ex, eval = FALSE}
NumericVector f_copy(NumericVector x) {
  return pow(x, 2);
}

NumericVector f_constref(const NumericVector& x) {
  return pow(x, 2);
}

// [[Rcpp::export]]
NumericVector f_copyref(const bool copy) {
  NumericVector x = runif(100000);
  if (copy) {
    return f_copy(x);
  } else {
    return f_constref(x);
  }
}
```

### Benchmark

```{r constref-bench, cache = TRUE}
bench::mark(
  f_copyref(TRUE),
  f_copyref(FALSE),
  check = FALSE
)
```

## Sugar

- Rcpp contains a wealth of syntactic **sugar**
- Often versions of R's vectorized functions

```{Rcpp rcpp-sum-sugar, eval = FALSE}
// [[Rcpp::export]]
double sum_cpp_sugar(const Rcpp::NumericVector& x) {
  return Rcpp::sum(x);
}
```

## Premature Optimization

- Most C++ compilers will optimize the code for you.
- What you see in the source code is **not** what you get.
- Temporary variables are often optimized away.
- Copy elisions

## Exercise

- Implement `cpp_sd()` using Rcpp that computes the standard deviation of a
  (numeric) vector. Benchmark against `sd()`.
- Remember to test your functions.
- Don't use `Rcpp:sd()`, please ☺
- If you have time over, try a different algorithm for computing the standard
  deviation.

```{Rcpp rcpp-sd, eval = FALSE, echo = FALSE}
// [[Rcpp::export]]
double cpp_sd(NumericVector x) {
  double out = 0.0;
  double x_mean = 0.0;

  int n = x.size();

  for (int i = 0; i < n; ++i) {
    out += x[i] / n;
  }

  for (int i = 0; i < n; ++i) {
     out += std::pow(x[i] - x_mean, 2);
  }

  return std::sqrt(out / (n - 1));
}
```

. . .

```{r sd-bench, echo = FALSE, cache = TRUE}
x <- rnorm(1e5)
bench::mark(cpp_sd(x), sd(x), check = FALSE) |> plot()
```

## Von Mises Rejection Sampling

### For-Loop Version

```{r vM-rejection, cache = TRUE}
rvonmises <- function(n, kappa) {
  y <- numeric(n)
  for (i in 1:n) {
    reject <- TRUE
    while (reject) {
      y0 <- runif(1, -pi, pi)
      u <- runif(1)
      reject <- u > exp(kappa * (cos(y0) - 1))
    }
    y[i] <- y0
  }
  y
}
```

### Vectorized Version

:::: {.columns}

::: {.column width="47%"}

```{r vM-rejection-fast, cache = TRUE}
new_sampler <- function(generator) {
  alpha <- 1
  function(n, ...) {
    y <- list()
    j <- 1
    l <- 0
    while (l < n) {
      m <- ceiling((n - l) / alpha)
      y[[j]] <- generator(m, ...)
      l <- l + length(y[[j]])
      if (j == 1) {
        alpha <<- (l + 1) / (m + 1)
      }
      j <- j + 1
    }
    unlist(y)[1:n]
  }
}
```

:::

::: {.column width="47%"}

```{r vM-rejection-vec-ran, cache = TRUE}
vonmises_generator <- function(m, kappa) {
  y <- runif(m, -pi, pi)
  u <- runif(m)
  accept <- u <= exp(kappa * (cos(y) - 1))
  y[accept]
}
```

```{r vM-rejection-vec, cache = TRUE}
rvonmises_vec <-
  new_sampler(vonmises_generator)
```

:::

::::

### Rcpp Implementation

```{Rcpp vMsim-cpp, eval = FALSE}
// [[Rcpp::export]]
NumericVector rvonmises_cpp(const int n, const double kappa) {
  NumericVector y(n);
  int i = 0;

  while (i < n) {
    double y0 = R::runif(-M_PI, M_PI);
    bool accept = R::runif(0, 1) <= exp(kappa * (cos(y0) - 1));
    if (accept) {
      y[i] = y0;
      i++;
    }
  }

  return y;
}
```

```{r vMsim3, dependson="vMsim-cpp", fig.width = 12, echo = FALSE}
par(mfrow = c(1, 2))
f <- function(x, k) exp(k * cos(x)) / (2 * pi * besselI(k, 0))
x <- rvonmises_cpp(100000, 0.5)
hist(x, breaks = seq(-pi, pi, length.out = 20), prob = TRUE)
curve(f(x, 0.5), -pi, pi, col = "blue", lwd = 2, add = TRUE)
x <- rvonmises_cpp(100000, 2)
hist(x, breaks = seq(-pi, pi, length.out = 20), prob = TRUE)
curve(f(x, 2), -pi, pi, col = "blue", lwd = 2, add = TRUE)
par(mfrow = c(1, 1))
```

```{r vMsim-cpp-runtime, dependson=c("vMsim-cpp", "vM-rejection-vec", "vM-rejection"), echo = FALSE, fig.width = 11}
bench::mark(
  rvonmises(1000, kappa = 5),
  rvonmises_vec(1000, kappa = 5),
  rvonmises_cpp(1000, kappa = 5),
  check = FALSE
) |>
  plot()
```

## The Standard Template Library (STL)

- A library of generic algorithms, data structures, and iterators for C++. --

- Accessed via the `std` namespace.
- Provides a number of useful functions for working with vectors and other
  containers.

. . .

### Efficiently Growing Vectors

Unlike R and Rcpp vector, `std::vector()` grows efficiently.

```cpp
std::vector<int> x;

for (int i = 0; i < 10; ++i) {
  x.emplace_back(i)
}
```

## Linear Algebra

### RcppArmadillo

```cpp
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat armaMatrixMultiply(const arma::mat &A, const arma::mat &B) {
  return A * B;
}
```

. . .

### RppEigen

```cpp
#include <RcppEigen.h>
// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::export]]
Eigen::MatrixXd eigenMatrixMultiply(const Eigen::MatrixXd &A,
                                    const Eigen::MatrixXd &B) {
  return A * B;
}
```

## R Markdown

Can put the code in Rcpp chunks, which will be automatically compiled and
exported.

```{Rcpp rcpp-odd-ex, echo = FALSE}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
bool is_odd_cpp(int num = 10) {
   bool result = (num % 2 == 1);
   return result;
}
```

:::: {.columns}

::: {.column width="47%"}

<!-- prettier-ignore-start -->

```{Rcpp}`r ''`
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
bool is_odd_cpp(int num = 10) {
   bool result = (num % 2 == 1);
   return result;
}
```
````

<!-- prettier-ignore-end -->

:::

::: {.column width="47%"}

```{r}
is_odd_cpp(7)
```

:::

::::

## Packages

- Best practice for Rcpp code is actually to write a package.
- Not as complicated as you might think!
- Facilitates reproducibility
- If we have time, we might cover in course.

:::: {.columns}

::: {.column width="47%"}

### R Packages

Great book to get started; free and available online at <https://r-pkgs.org>.

:::

::: {.column width="47%"}

![](../images/r-pkgs.png)

:::

::::

## Exercise

Recall the running mean implementation:

```{r run-mean}
run_mean <- function(y, k) {
  n <- length(y)
  m <- floor((k - 1) / 2)
  k <- 2 * m + 1
  y <- y / k
  s <- rep(NA, n)
  s[m + 1] <- sum(y[1:k])
  for (i in (m + 1):(n - m - 1)) {
    s[i + 1] <- s[i] - y[i - m] + y[i + 1 + m]
  }
  s
}
```

- Rewrite this in Rcpp and compare the performance.
- Test your implementation
- Benchmark it against `run_mean()`

```{Rcpp rcpp-runmean, echo = FALSE, eval=FALSE}
// [[Rcpp::export]]
NumericVector run_mean_cpp(NumericVector y, int k) {
  int n = y.size();
  int m = floor((k - 1) / 2);
  int kk = 2 * m + 1;
  NumericVector s = rep(NA_REAL, n);
  s[m] = 0;
  for(int i = 0; i < kk; ++i)
    s[m] += y[i] / kk;
  for(int i = m; i < (n - m - 1); ++i)
    s[i + 1] = s[i] - y[i - m] / kk + y[i + 1 + m] / kk;
  return s;
}
```

### Testing

```{r runmean-test}
library(testthat)

test_that("R and C++ running mean functions are equivalent", {
  y <- rnorm(7)
  expect_equal(run_mean(y, k = 3), run_mean_cpp(y, k = 3))
})
```

### Benchmarking

```{r runmean-bench, message = FALSE, cache = TRUE}
y <- rnorm(4096)
run_bench <- bench::press(
  n = c(512, 1024, 2048, 4096),
  {
    y <- rnorm(n)
    bench::mark(
      run_mean(y, k = 11),
      run_mean_cpp(y, k = 11),
      check = FALSE
    )
  }
)
```

```{r plot-bench, fig.width = 12, fig.height = 6, echo = FALSE}
plot(run_bench)
```

## Getting Help

- [The unofficial Rcpp API documentation](https://thecoatlessprofessor.com/programming/cpp/unofficial-rcpp-api-documentation/)
- [The many official vignettes](https://cran.r-project.org/web/packages/Rcpp/index.html)
- [Rcpp For Everyone](https://teuder.github.io/rcpp4everyone_en/) by Masaki E.
  Tsuda
