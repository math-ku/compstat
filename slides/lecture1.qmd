---
title: "Introduction"
---

{{< include _common.qmd >}}

```{r init, echo=FALSE, message=FALSE, warning=FALSE}
load(here::here("data", "top100dih.RData"))
phipsi2 <- na.omit(dataset)
phipsi <- read.table(here::here("data", "phipsi.tsv"), header = TRUE)
phipsi[, c("phi", "psi")] <- pi * phipsi[, c("phi", "psi")] / 180

options(width = 50)
```

## What is Computational Statistics?

It is a broad field, where meaning depends on context.

\bigskip

. . .

One definition is that it is **the use of computational methods to solve
statistical problems**, for instance

. . .

- simulation,
- optimization,
- numerical integration,
- data analysis, and
- visualization.

## A Running Example

:::: {.columns}

::: {.column width="47%"}

Let's try to get a bit of flavor of what we will be doing in the course.

\bigskip

. . .

Throughout the course (and book) we will use a data set on angles, $\Phi$ and
$\Psi$, formed between two planes in protein structures.

:::

::: {.column width="47%"}

![Amino Acid Angles](../images/PhiPsi_creative.jpg){width=90%}

:::

::::

## Histograms

A simple way to analyze the distributions of the angles $\Phi$ and $\Psi$ is the
**histogram**.

\bigskip

. . .

:::: {.columns}

::: {.column width="47%"}

```{r hist1-src}
#| eval: false
#| fig-cap: A histogram of the $\Psi$ variable in the amino acid data
ggplot(phipsi, aes(x = phi)) +
  geom_histogram() +
  geom_rug(alpha = 0.5) +
  labs(
    x = expression(Phi),
    y = "Density"
  )
```

:::

::: {.column width="47%"}

```{r hist1-show}
#| ref-label: hist1-src
#| fig-height: 2.1
#| echo: false
```

:::

::::

## Density Estimation

Histograms are not very smooth. If we allow ourselves to make stronger
assumptions, we can get a smoother estimate of the distribution, using **kernel
density estimation** (KDE).

. . .

\medskip

:::: {.columns}

::: {.column width="47%"}

```{r dens-src}
#| eval: false
ggplot(phipsi, aes(x = phi)) +
  geom_density() +
  geom_rug(alpha = 0.5) +
  labs(
    x = expression(Phi),
    y = "Density"
  )
```

:::

::: {.column width="47%"}

```{r dens-fig}
#| echo: false
#| ref-label: dens-src
#| fig-height: 2

```

:::

::::

. . .

\bigskip

But how is this KDE actually computed? Doing this efficiently is a
**computational statistics** problem.

## Statistical Topics of the Course

The course can be broken down into a number of **statistical** and
**computational** topics.

\bigskip

. . .

There are three statistical topics in the course:

\pause

### Smoothing

Descriptive tool for summarizing and visualizing data, as well as a
nonparametric estimation method.

. . .

### Monte Carlo Methods

Broad class of methods for using random input for computations, such as sampling
from a distribution.

. . .

### Optimization

Methods for optimizing (minimizing or maximizing) functions, such as likelihood
functions.

## Computational Topics of the Course

### Implementation

We will learn how to implement statistical methods in R, using object-oriented
programming and functional programming.

. . .

### Correctness

We will learn how to ensure that our code is correct, using testing and
debugging.

. . .

### Efficiency

We will learn how measure performance and find bottlenecks in our code using
profiling and benchmarking, and how to optimize it.

## Teaching Staff

:::: {.columns}

::: {.column width="47%"}

### Instructor

Johan Larsson, postdoctoral researcher

![Johan](../images/johan.jpg){width=50%}

. . .

#### Contact

Use Absalon for course-related questions and email (see Absalon) for personal
matters.

:::

. . .

::: {.column width="47%"}

### Teaching Assistant

Jinyang Liu, PhD student in machine learning

![Jin](../images/jinyang.jpg){width=50%}

:::

::::

## Assignments

Four assignments make up the bulk of the course work.

. . .

\bigskip

For each assignment, there are two alternatives (A and B). You will pick one.

. . .

\bigskip

Each assignment is tied to a particular **topic**:

1. Smoothing
2. Univariate simulation
3. The EM algorithm
4. Stochastic optimization

## Presentations

There will be four presentation sessions (week 3, 4, 6, 7)^[Not counting the
potato harvesting week when you are off.]

. . .

\bigskip

You will divide into groups of 2-3 students and present your solution to one of
the assignments during one of the sessions.

. . .

\bigskip

You will register for groups and assignments in
[Absalon](https://absalon.ku/dk).

. . .

\bigskip

Presentation is compulsory but not graded. We expect solutions to be work in
progress.

. . .

## Oral Examination

The main examination is an oral exam based on your assignments.

\bigskip

. . .

You will prepare four presentations, one for each assignment you picked.

\bigskip

. . .

At the exam, you will present one of these at random.

## Schedule

:::: {.columns}

::: {.column width="47%"}

### Lectures

- Tuesdays and Thursdays, 10:15–12:00 (Johan)

. . .

### Exercise Sessions

- Thursdays, 08:15–10:00 (Jinyang)

. . .

### Presentations

- Thursdays, 13:15–15:00 (Johan)
- Only weeks 3, 4, 6, and 7

:::

. . .

::: {.column width="47%"}

### Examination

- November 6-8 (8.15-17.30, tentative)
- Rooms to be announced

:::

::::

## Exercise Sessions

Exercise sessions will revolve around a central topic, for instance

. . .

- How to organize your code
- How to use generative AI effectively

. . .

They are also an opportunity to get help with the exercises. To make best use of
your time, make sure you have at least _tried_ each of them.

. . .

Later on, the exercise sessions is where you will get assistance with your
projects.

## Course Literature

### Computational Statistics with R

Main textbook for the course, written by Niels Richard Hansen.

\medskip

. . .

It is available online at [cswr.nrhstat.org/](https://cswr.nrhstat.org). Not yet
complete, but we only use parts that are.

. . .

\medskip

There is a
[companion package](https://github.com/nielsrhansen/CSwR/tree/master/CSwR_package):

```{r}
#| eval: false
pak::pak("github::nielsrhansen/CSwR/CSwR_package")
```

. . .

### Advanced R

Auxiliary textbook, written by Hadley Wickham.

\medskip

. . .

Available online at [adv-r.hadley.nz](https://adv-r.hadley.nz/).

. . .

\medskip

Covers more advanced R programming topics, among which we use a few

## Online Resources

:::: {.columns}

::: {.column width="70%"}

### Absalon

Main source for information and communication about the course. Accessed at
[absalon.ku.dk](https://absalon.ku.dk/).

. . .

### Resources Page

Course content will be uploaded to
[github.io/math-ku/compstat](https://math-ku.github.io/compstat/).

. . .

This is where you will a detailed schedule of the course, slides, and the
assignments.

:::

::: {.column width="25%"}

![Absalon](../images/absalon.jpg){width=100%}

:::

::::

## Generative AI

Generative AI (e.g. ChatGPT, Copilot, Bard, etc.) are powerful tools.

\bigskip

. . .

You are allowed to use them in this course, but with some caveats:

. . .

- You must understand the results.
- You must acknowledge their use in your assignments and how you used them.

. . .

\bigskip

:::: {.columns}

::: {.column width="47%"}

### Copilot

Access to GitHub Copilot is available for free to students, via
[GitHub Education](https://education.github.com).

:::

::: {.column width="47%"}

![](../assets/images/github-education.png){width=100%}

:::

::::

# Programming in R

## What is R?

R is a programming language and application (command-line interface) for
statistical computing and graphics.

. . .

\bigskip

It is widely used among statisticians and data miners for developing statistical
software and data analysis.

. . .

### Why R?

It is free, open source, and cross-platform.

. . .

### Why not Python/Julia?

R has a large number of packages for statistical computing and graphics.

. . .

\bigskip

My personal opinion is that:

- R is better suited for visualization and exploratory data analysis, while
- Python is better suited for general-purpose programming and machine learning,
  and
- Julia is a best for numerical computing.

## Prerequisite R Knowledge

We expect knowledge of

- data structures (vectors, lists, data frames),
- control structures (loops, if-then-else),
- function calling,
- interactive and script usage (`source`) of R.

. . .

All of this is covered in chapters 1-5 of
[Advanced R](https://adv-r.hadley.nz/).

. . .

\bigskip

We do not expect that you are an expert in R.

## RStudio and Positron

### RStudio

An integrated developed environment (IDE) for R. Stable and full-featured.

. . .

### Positron

A newer alternative, that has support for other programming languages as well.

. . .

\bigskip

If you haven't tried any of these before, we recommend you use Positron.

## Tidyverse

:::: {.columns}

::: {.column width="54%"}

The [tidyverse](https://www.tidyverse.org/) is a suite of packages for wrangling
with, exploring, and visualizing data.

:::

::: {.column width="40%"}

![The Tidyverse](../assets/images/tidyverse.png)

:::

::::

. . .

Throughout the slides, I assume that you have it installed and loaded.

```{r}
install.packages("tidyverse")
library(tidyverse)
```

## Best Practices

Always write your code in scripts (`.R` files).

\bigskip

. . .

Manage your files in project directories, one for each project.

## Getting Help with R

### Google It

Especially good for error messages.

. . .

### Generative AI

- Also great for error messages and debugging
- _Caution_: You need to understand the results, especially when you ask it to
  create something for you.

. . .

### Absalon Discussion Forum

Use the fact that there are twenty other people in the course with exactly the
same problem.

# Functions

## Functions in R

Everything that happens in R is the result of a function call. Even `+`, `[` and
`<-` are functions.

. . .

\medskip

An R function takes a number of _arguments_, and when a function call is
evaluated it computes a _return value_.

. . .

\medskip

Functions can return any R object, including functions!

. . .

\medskip

Implementations of R functions are collected into source files, which can be
organized into packages.

## Why Functions?

Technically, you could write all your code in a single script. So why use
functions?

. . .

\bigskip

Functions help you structure your code, make it reusable, and make it easier to
test and debug.

. . .

\bigskip

A well-designed function has a single purpose, which makes it easier to
understand and reason about.

. . .

### Rule of Thumb

If you find yourself writing the same piece of code more than twice, then it is
probably a good idea to turn it into a function.

## Function Syntax

:::: {.columns}

::: {.column width="47%"}

Here is a simple function that takes two arguments and returns their sum.

```{r}
f <- function(x, y) {
  x + y
}
```

. . .

A function has three components: **arguments**, **body**, and **environment**.

\bigskip

. . .

### Arguments

In this case, `x` and `y` are the arguments.

:::

. . .

::: {.column width="47%"}

### Body

The body of the function is everything inside the curly braces `{}`, that is,
`x + y`.

. . .

### Environment

The environment is where the function was created. It is used to look up
variables that are not defined inside the function.

```{r}
environment(f)
```

:::

::::

## Arguments

Arguments are specified in the parentheses after the function name.

. . .

### Arguments can have default values

```{r}
g <- function(x, y = 2) {
  x + y
}

g(3) # y takes the default value 2
```

. . .

### Named arguments can be passed in any order.

```{r}
g(y = 3, x = 2)
```

## Copy-on-Write

R uses **copy-on-write** semantics for function arguments, which means that
arguments are only copied if they are modified inside the function.

. . .

\bigskip

This makes function calls efficient, and also means that you can modify
arguments without shooting yourself in the foot.

. . .

:::: {.columns}

::: {.column width="47%"}

```{r}
h <- function(x) {
  x[1] <- 100
  x
}

a <- 1:5

h(a) # a is not modified
```

. . .

:::

::: {.column width="47%"}

```{r}
a # a is still 1:5
```

. . .

### `<<-` Operator

You can use the `<<-` operator to modify variables in the parent environment,
but please don't.

:::

::::

## Environment and Scoping

When a function is called, a new environment is created for the function.

\medskip

. . .

This environment is used to look up variables that are not defined inside the
function.

\medskip

. . .

The new environment has as its parent the environment where the function was
created.

\medskip

. . .

:::: {.columns}

::: {.column width="47%"}

This is called **lexical scoping**.

```{r}
x <- 10
f <- function(y) {
  x + y
}
f(5)
```

:::

::: {.column width="47%"}

Assuming that `x` is not defined inside `f()`, R looks for `x` in the
environment where `f()` was created, which is the global environment in this
case.

. . .

As a rule of thumb, avoid using variables from the parent environment inside
functions.

:::

::::

## Return Values

The return value of a function is the value of the last expression in the body.

. . .

\bigskip

Unless you explicitly use the `return()` function, which immediately exits the
function and returns the specified value.

```{r}
f <- function(x, y) {
  return(x + y)
  x * y # This line is never reached
}
```

. . .

Whether or not to use `return()` is a matter of style. Personally, I prefer to
not use it unless returning early.

## Functional Programming

Functions are **first-class citizens**: they can be passed as arguments to other
functions, returned as values from functions, and assigned to variables. R is a
**functional programming** language.

\bigskip

. . .

This allows for a high degree of abstraction and code reuse, for instance
through the use of the `apply` family of functions.

. . .

Let's write our own apply function.

\bigskip

```{r own-apply}
our_apply <- function(x, fun) {
  val <- numeric(length(x))
  for (i in seq_along(x)) {
    val[i] <- fun(x[[i]])
  }
  val
}
```

## Testing Our Apply Function

```{r}
sapply(1:10, exp)
```

. . .

```{r}
our_apply(1:10, exp)
```

. . .

### Assumptions of `our_apply()`

`x` is a "list-like" structure, `fun` takes a single argument, and `fun` returns
a numeric.

## What if `fun` Needs Additional Arguments?

Then we get an error:

```{r, error=TRUE, echo=-1}
set.seed(1)
our_apply(1:10, rpois)
```

. . .

### Anonymous Functions

We can use an anonymous function to pass additional arguments to `fun()`.

```{r}
our_apply(
  1:10,
  function(lambda) rpois(1, lambda = 0.9)
)
```

## Ellipsis (`...`)

Arguments can be forwarded via `...` (ellipsis), which allows us to pass
additional arguments to `fun()`.

. . .

```{r own-apply-2}
our_apply <- function(x, fun, ...) {
  # <1>
  val <- numeric(length(x))
  for (i in seq_along(x)) {
    val[i] <- fun(x[[i]], ...) # <2>
  }
  val
}
```

1. `...` in the argument list of `our_apply()` collects additional arguments.
2. `...` in the call to `fun()` passes these additional arguments to `fun()`.

. . .

```{r}
our_apply(1:10, rpois, n = 1) # n is passed to fun
```

## Assertions

Assert that arguments to a function are valid and stop early if they are not.

. . .

\bigskip

Simplest way to do this is to use `stopifnot()`:

```{r}
#| error: true
my_mean <- function(x) {
  stopifnot(is.numeric(x))
  sum(x) / length(x)
}

my_mean(c("asdf", "qwer"))
```

. . .

If `x` is not numeric, we would otherwise get an error deep inside `sum()`.

. . .

## Custom Error Messages

For more control over the error message, use `if` and `stop()`.

```{r}
my_mean <- function(x) {
  if (!is.numeric(x)) {
    stop("x must be numeric")
  }
  sum(x) / length(x)
}
```

## Document Your Functions

Document your functions, including their arguments, return values, and any side
effects.

. . .

\medskip

Documentation can be written using simple comments or a documentation system
like [roxygen2](https://roxygen2.r-lib.org/).

. . .

\medskip

### Why, not What

Prefer to document **why** something is done, not just **what** is done.

. . .

\medskip

In good code, the **what** is often clear from the code itself.

. . .

\medskip

Functions, if named properly, often serve as documentation by themselves.

## Naming Functions

> There are only two hard things in Computer Science: cache invalidation and
> naming things.
>
> \medskip
>
> \hfill _--Phil Karlton_

. . .

:::: {.columns}

::: {.column width="47%"}

### Favor Descriptive Names

First check if you can use a _verb_, which signals **intent**.

\medskip

. . .

Better descriptive but long, than short but cryptic.

. . .

### Honor Common Conventions

Avoid `.` in names; it is used for **methods** (upcoming).

. . .

:::

::: {.column width="47%"}

### Use a Consistent Style

- `lowercase`
- `snake_case` (tidyverse)
- `camelCase`
- `UpperCamelCase`

. . .

### Namespace Clashes

Avoid names of existing functions.

:::

::::

## Best Practices

### Keep Functions Short and Focused

Functions should do one thing and do it well. If a function is too long or
complex, consider breaking it up into smaller functions.

. . .

### Testing

Write tests for your functions to ensure that they work as expected. (More on
this later in the course.)

. . .

### Debugging

Use `browser()`, `traceback()`, and `debug()` to debug your functions. (More on
this later in the course.)

## Summary

Functions are the buildings block of R code, and first-class citizens.

\medskip

. . .

They help make your code organized, reusable, testable, and easy to debug.

\medskip

. . .

Write short functions and name them descriptively.

# Exercises

### Exercise 1: Write a function with a default argument

Write a function `greet` that takes a name as an argument and prints “Hello,
<name>!”. If no name is given, it should print “Hello, world!”.

. . .

### Exercise 2: Count missing values

Write a function `count_na` that takes a vector and returns the number of
missing (`NA`) values in it.

. . .

### Exercise 3: Check if a number is even

Write a function `is_even()` that returns `TRUE` if its argument is even,
`FALSE` otherwise.

<!-- # Benchmarking -->
<!---->
<!-- ## R Is Slow ... -->
<!---->
<!-- ... when used like a low-level language. -->
<!---->
<!-- - R is an **interpreted** (as opposed to _compiled_) language. -->
<!-- - It was written mainly for specifying statistical models (not for developing -->
<!--   new numerical methods). -->
<!-- - It is suitable for high-level programming where most low-level computations -->
<!--   are implemented in a compiled language (e.g. `lm()` and `qr()`.) -->
<!-- - It is also quite old. -->
<!---->
<!-- ## R Is Fast ... -->
<!---->
<!-- ... when most computations are carried out by calls to compiled code. -->
<!---->
<!-- ```{r} -->
<!-- x <- rnorm(1e4) -->
<!-- bench_res <- bench::mark( -->
<!--   loop = { -->
<!--     y <- numeric(length(x)) -->
<!--     for (i in seq_along(x)) { -->
<!--       y[i] <- 10 * x[i] -->
<!--     } -->
<!--     y -->
<!--   }, -->
<!--   vectorized = 10 * x -->
<!-- ) -->
<!-- ``` -->
<!---->
<!-- ## Plot Benchmark Results -->
<!---->
<!-- ```{r bench-plot} -->
<!-- #| fig-width: 5 -->
<!-- #| fig-cap: Benchmark results for a loop vs. a vectorized computation -->
<!-- autoplot(bench_res) -->
<!-- ``` -->
<!---->
<!-- ## Vectorization -->
<!---->
<!-- Vectorization is the process of rewriting code to use vectorized operations, -->
<!-- which operate on entire vectors at once, instead of using loops to operate on -->
<!-- individual elements. -->
<!---->
<!-- . . . -->
<!---->
<!-- The term is somewhat misleading, since it does not necessarily involve -->
<!-- vector processors. -->
<!---->
<!-- . . . -->
<!---->
<!-- ### Example: Counting Zeros, Vectorized -->
<!---->
<!-- ```{r} -->
<!-- count_zeros_vec <- function(x) { -->
<!--   sum(x == 0) -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- . . . -->
<!---->
<!-- - `x == 0` checks if each entry of `x` is 0 and returns a vector of logicals. -->
<!-- - `sum()` computes and returns the sum of all elements in a vector. Logicals are -->
<!--   coerced to integers. -->
<!-- - In this case the vectorized implementation is cohesive and clear. -->
<!-- - The vectorized computations are performed by compiled code (C/C++/Fortran), -->
<!--   which run faster than pure R code. -->
<!-- - Writing vectorized code requires a larger knowledge of R functions. -->
<!---->
<!-- ## Beware of Loops in Disguise -->
<!---->
<!-- Just because you ran a function, it does not mean that it is vectorized. -->
<!---->
<!-- . . . -->
<!---->
<!-- ```{r} -->
<!-- #| fig-width: 5 -->
<!-- #| fig-height: 2 -->
<!-- bench::mark( -->
<!--   sapply(x, function(x_i) 10 * x_i), -->
<!--   10 * x -->
<!-- ) |> -->
<!--   plot() -->
<!-- ``` -->
<!---->
<!-- ## Development Cycle Sketch -->
<!---->
<!-- - Is there a good-enough existing implemention for your problem? If yes, then -->
<!--   you are done. -->
<!-- - If not, implement a solution and test it. Does it solve your problem -->
<!--   sufficiently well? If yes, then you're done. -->
<!-- - If not, then profile (next week!), benchmark, and debug (week 5). Then -->
<!--   refactor and optimize. -->
<!---->
<!-- . . . -->
<!---->
<!-- ### The Root of All Evil -->
<!---->
<!-- \medskip -->
<!---->
<!-- > We _should_ forget about small efficiencies, say about 97% of the time: -->
<!-- > premature optimization is the root of all evil. Yet we should not pass up our -->
<!-- > opportunities in that critical 3%. -->
<!-- > -->
<!-- > _—Donald Knuth_ -->
<!---->
<!-- ## Example: Density Estimation -->
<!---->
<!-- ```{r kernDens} -->
<!-- kern_dens <- function(x, h, m = 512) { -->
<!--   rg <- range(x) -->
<!--   xx <- seq(rg[1] - 3 * h, rg[2] + 3 * h, length.out = m) -->
<!--   y <- numeric(m) -->
<!---->
<!--   for (i in seq_along(xx)) { -->
<!--     for (j in seq_along(x)) { -->
<!--       y[i] <- y[i] + exp(-(xx[i] - x[j])^2 / (2 * h^2)) -->
<!--     } -->
<!--   } -->
<!---->
<!--   y <- y / (sqrt(2 * pi) * h * length(x)) -->
<!---->
<!--   list(x = xx, y = y) -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- ## Vectorizing Our Density Estimator -->
<!---->
<!-- ```{r kernDens-vec} -->
<!-- kern_dens_vec <- function(x, h, m = 512) { -->
<!--   rg <- range(x) -->
<!--   xx <- seq(rg[1] - 3 * h, rg[2] + 3 * h, length.out = m) -->
<!--   y <- numeric(m) -->
<!--   const <- (sqrt(2 * pi) * h * length(x)) -->
<!---->
<!--   for (i in seq_along(xx)) { -->
<!--     y[i] <- sum(exp(-(xx[i] - x)^2 / (2 * h^2))) / const -->
<!--   } -->
<!---->
<!--   list(x = xx, y = y) -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- ## Benchmarking -->
<!---->
<!-- ```{r kern-bench} -->
<!-- kern_bench <- bench::mark( -->
<!--   kern_dens(phipsi$psi, 0.2), -->
<!--   kern_dens_vec(phipsi$psi, 0.2) -->
<!-- ) -->
<!-- ``` -->

<!-- ## Plot Benchmark Results -->
<!---->
<!-- ```{r kern-bench-autoplot} -->
<!-- #| message: false -->
<!-- #| fig-height: 2.5 -->
<!-- #| fig-width: 5 -->
<!-- plot(kern_bench) -->
<!-- ``` -->
<!---->
<!-- ## Parameterized Benchmarking -->
<!---->
<!-- ```{r kern-bench-grid, cache = TRUE, message = FALSE} -->
<!-- kern_benchmarks <- bench::press( -->
<!--   n = 2^(6:9), -->
<!--   m = 2^(5:11), -->
<!--   { -->
<!--     bench::mark( -->
<!--       loop = kern_dens(x[1:n], h = 0.2, m = m), -->
<!--       vec = kern_dens_vec(x[1:n], h = 0.2, m = m) -->
<!--     ) -->
<!--   } -->
<!-- ) -->
<!-- ``` -->

<!-- ## Plotting Results -->
<!---->
<!-- ```{r kern-bench-fig} -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-width: 7 -->
<!-- library(tidyverse) -->
<!-- mutate(kern_benchmarks, expression = as.character(expression)) |> -->
<!--   ggplot(aes(m, median, color = expression)) + -->
<!--   geom_point() + -->
<!--   geom_line() + -->
<!--   facet_grid(cols = vars(n)) -->
<!-- ``` -->
