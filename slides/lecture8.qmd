---
title: "Testing And Debugging"
---

{{< include _common.qmd >}}

## Last Time: Optimization


### Gradient Descent

Iterative algorithm to find a local minimum of a differentiable function

. . .

\begin{algorithm}[H]
  \caption{Gradient descent}
  \KwData{Step size $t > 0$}
  \Repeat{convergence}{
    $x \gets x - t \nabla f(x)$\;
  }
  \Return{$x$}
\end{algorithm}

. . .

## Newton Method

Iterative algorithm to find a local minimum of a twice-differentiable function

. . .

\begin{algorithm}[H]
  \caption{Newton method}
  \KwData{Tolerance $\epsilon > 0$}
  \Repeat{convergence}{
    $d \gets -H_f(x)^{-1} \nabla f(x)$\;
    $\alpha \gets 1$\;
    \While{$f(x + \alpha d) > f(x) + 0.1 \alpha \nabla f(x)^T d$}{
      $\alpha \gets 0.5 \alpha$\;
    }
    $x \gets x + \alpha d$\;
  }
  \Return{$x$}

# Testing

## Testing

Testing is the process of executing a program with the intent of finding
bugs.

. . .

# Debugging

## Debugging

Bugs are common, maybe inevitable.

\medskip\pause

Debugging is the process of finding and fixing bugs.

![Down the rabbit hole.](../images/xkcd-debugging.png){width=80%}

---

![The "first" bug.](../images/first-bug-reduced.jpg){width=80%}

## Poisson Regression

```{r poisson-regression}
n <- 1000
x <- rnorm(n)
y <- rpois(n, exp(x))
X <- model.matrix(y ~ x)
```

. . .

```{r poisson-implementations}
Xty <- drop(crossprod(X, y))

objective <- function(beta) {
  (sum(exp(X %*% beta)) - beta %*% Xty) / nrow(X)
}

gradient <- function(beta) {
  (colSums(drop(exp(X %*% beta)) * X) - Xty) / nrow(X)
}
```

. . .

Gradient descent and Newton method implementations can be found in
[`debugging.R`](R/debugging.R).

```{r source-debugging-file, cache=FALSE}
source(here::here("R/debugging.R"))
```

## Testing

```{r run-gd}
gradient_descent(c(0, 0), objective, gradient, t0 = 1, epsilon = 1e-8)
```

. . .

```{r run-glm}
glm(y ~ x, family = "poisson")
```

### Traceback

- Sometimes enough to simply look at the call stack

## Entering Debug Mode

Two common ways to enter debug mode:

- `browser()`: Stops execution and enters debug mode
- Set a breakpoint in RStudio.

. . .

:::: {.columns}

::: {.column width="47%"}

### `browser()`

- Can be placed anywhere in the code
- Stops execution and enters debug mode

:::

::: {.column width="47%"}

### RStudio Breakpoints

- Visual breakpoints
- Easy to set and remove (click in the margin)
- No need to modify the code
- But cannot be conditionally set
- Sometimes won't work

:::

::::

## Buggy Newton Method

```{r def-hessian}
hessian <- function(beta) {
  (crossprod(X, drop(exp(X %*% beta)) * X)) / nrow(X)
}
```

```{r run-newton, error=TRUE, linewidth = 80}
newton_method(c(0, 0), objective, gradient, hessian)
```

## Exercise: Debugging `newton_method()`

- Download and open [`debugging.R`](R/debugging.R) in RStudio.
- Create another script and define `objective()`, `gradient()`, and `hessian()`
  by copying from these slides.
- Source `debugging.R` and test that `gradient_descent()` works. Now try
  `newton_method()`. Oh no, there's an error!
- Insert a breakpoint before the `while` loop and inspect the values of
  `objective(x_new)`, `values`, `alpha`, `beta` and `grad_d_prod` from within
  the browser.
- Explain and fix the bug. Remove the breakpoint.
- Source the fixed code and try calling `newton_method()`. What happens?
- Debug the code again, using breakpoints or `browser()`. Finally verify that
  `newton_method()` works.

## Debugging C++ Code (Rcpp)

- Unfortunately **not** easy.
- General problem is that C++ code is compiled, so what you see in C++ is not
  necessarily what is executed.
- We won't cover it here, but it **is** possible: see
  [these notes](https://github.com/wch/r-debug/blob/master/debugging-r.md) for
  instance.
