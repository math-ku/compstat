{
  "hash": "4c5f0ea80c69cf622f7ce73ecff41f60",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Rcpp\"\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n\n## Today\n\n### C++ and Rcpp\n\n- Why do we want to use C++?\n- What is **compiled** code?\n- How do we use Rcpp to connect R to C++?\n- What are the pitfalls and benefits of using Rcpp?\n\n## Why R?\n\nWhy are we even using R?\n\n. . .\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n\nBecause R lets us\n\n- work interactively,\n- explore and visualize data via a rich toolset,\n- easily retrieve or generate data,\n- summarize and report (via RMarkdown/Quarto), and\n- make use of a comprehensive ecosystem of packages.\n\n:::\n\n::: {.column width=\"47%\"}\n\n![](../images/r-logo.svg)\n\n:::\n\n::::\n\n## Why _Not_ R?\n\nIt is often slow due to being an **interpreted** language.\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n\n### Interpreted Languages\n\n- Execution of code happens line by line.\n- Many functions are written in C, but you still have to call them from R.\n- **Examples:** R, Python, Matlab, Javascript.\n\n:::\n\n::: {.column width=\"47%\"}\n\n### Compiled Languages\n\n- Code is translated into machine code before execution.\n- This makes it faster.\n- **Examples:** C, C++, Fortran, Java\n\n:::\n\n::::\n\n## Compiled vs Interpreted Languages\n\n![](../images/chatgpt-compiled-interpreted.png){width=63%}\n\n## Compiled Code\n\n### C++ Code\n\n```cpp\nint add(int a, int b) { return a + b; }\n\nint main() {\n  std::cout << add(2, 3) << std::endl;\n  return 0;\n}\n```\n\n. . .\n\n### Assembly Representation\n\n```assembly\n0000000000401130 <main>:\n  401130:       55                      push   %rbp\n  401131:       48 89 e5                mov    %rsp,%rbp\n  401134:       48 83 ec 10             sub    $0x10,%rsp\n  ···           ···                     ···    ···\n  401149:       8b 45 f8                mov    -0x8(%rbp),%eax\n  401165:       c9                      leaveq\n  401166:       c3                      retq\n```\n\n## Why C++?\n\n- C++ generates machine code: no longer have to be scared of loops!\n- Pass by reference: no need to copy large objects.\n- Access to external C++ libraries\n- Wrap and reuse C++ code with other languages\n- Compilation catches bugs early.\n\n. . .\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n\n## Why _Not_ C++?\n\n- Compiling adds overhead.\n- Debugging is more complicated.\n- Distributing code is more involved.\n\n:::\n\n::: {.column width=\"47%\"}\n\n![](../images/compiling.png){width=80%}\n\n:::\n\n::::\n\n## R Can Be Extended\n\nBut we can extend R by coupling it to a compiled language, like\n\n- C,\n- C++,\n- Fortran, and\n- Java.\n\n. . .\n\n### Problem\n\nDoing so has historically been **tedious** and **error-prone**.\n\n### Basic C++ Version of `sum()`\n\n\n::: {.cell}\n\n```{.c .cell-code}\n// foo.c\n#include <R.h>\n#include <Rinternals.h>\n\nextern \"C++\"\n{\n  SEXP sum_c(SEXP x)\n  {\n    x = PROTECT(coerceVector(x, REALSXP));\n    SEXP s = PROTECT(allocVector(REALSXP, 1));\n    double* x_ref = REAL(x);\n    double* s_ref = REAL(s);\n\n    for (int i = 0; i < length(x); i++)\n      s_ref[0] += x_ref[i];\n\n    UNPROTECT(2);\n\n    return s;\n  }\n}\n```\n:::\n\n\n### C++ Example (Continued)\n\nNext, we need to compile this into a binary file by calling:\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nR CMD SHLIB foo.c\n```\n:::\n\n\n. . .\n\nThen, in R, we would call this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndyn.load(\"foo.so\") # or `foo.dll` if on Windows\n```\n:::\n\n\n. . .\n\nFinally, access function by calling this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1.0, 1.5, -0.2, 0.1, 0.0)\n.Call(\"sum_c\", x = x)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.4\n```\n\n\n:::\n:::\n\n\n## Rcpp\n\nRcpp simplifies this process **considerably**.\n\n\n::: {.cell}\n\n```{.cpp .cell-code}\n// [[Rcpp::export]]\ndouble sum_cpp(Rcpp::NumericVector x) {\n  double total = 0;\n  const int n = x.size();\n\n  for (int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n\n  return total;\n}\n```\n:::\n\n\n### Exporting C++ Functions\n\nAutomizes the process of compiling, linking, and exporting.\n\n. . .\n\n### R Interface\n\n- Provides collection of classes to represent R objects\n  - `Rcpp::NumericalVector`\n  - `Rcpp::DataFrame`\n- Adds a number of functions, often vectorized, to manipulate these objects\n  - `Rcpp::sum()`\n  - `Rcpp::runif()`\n- Seamless transformation between R and C++ objects.\n\n## Installing Rcpp\n\n### Linux\n\nDepends on distro, but on Ubuntu call this:\n\n```r\nsudo\napt\ninstall\nr - base - dev\n```\n\n### OSX\n\nYou need Xcode. Open up a terminal and call this:\n\n```sh\nxcode-select --install\n```\n\n### Windows\n\nInstall [Rtools](https://cran.r-project.org/bin/windows/Rtools/).\n\n## Side-By-Side Comparison\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)\n\nsum_r <- function(x) {\n  total <- 0\n  for (i in seq_along(x)) {\n    total <- total + x[i]\n  }\n  total\n}\n```\n:::\n\n\n:::\n\n::: {.column width=\"47%\"}\n\n### C++\n\n```cpp\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum_cpp(NumericVector x) {\n  double total = 0;\n  const int n = x.size();\n  for (int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n  return total;\n}\n```\n\n:::\n\n::::\n\n## Writing Code in R and Rcpp\n\n### Notable Differences\n\n- **Vectors are indexed from 0**\n- Statements end with a semicolon (**`;`**)\n- The assignment operator is **`=`**\n- Input and output types need to be declared\n- Class methods have a different syntax (e.g. `x.size()` not `size(x)`)\n- An explicit `return` statement is required to return a value\n- For loops have a different syntax: `for (<init>; <check>; <increment>)`\n- You don't assign to create functions.\n\n. . .\n\n### Similarities\n\n- Rcpp classes, like `NumericVector` and `List`, unify data structures in R and\n  C++\n- Rcpp implements vectorized arithmetic (as in R)\n- Rcpp implements a long list of vectorized R-like functions\n\n## Including C++ Code in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)\n```\n:::\n\n\n--\n\nThe C++ code can be passed directly to the `cppFunction()` as a text string for\ncompilation and setting up an R interface.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncppFunction(\n  \"int one() {return 1;}\"\n)\n```\n:::\n\n\n. . .\n\nAnd then the function can be called from R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\none()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n## Source Files\n\nBetter to put C++ code in an `.cpp` file (for instance in `src/` folder) and use\n`sourceCpp()` (or RStudio's UI tool) to compile the code and set up the R\ninterface.\n\n. . .\n\nIn `R/my_r_experiment.R` (or similar), call\n\n```r\nsourceCpp(here::here(\"src/my_cpp_functions.cpp\"))\n```\n\n```\nmy_project/\n├── scripts/\n│   └── my_r_experiment.R    # R script\n├── src/\n│   └── my_cpp_functions.cpp # Source for C++ functions\n└── my_rproject.Rproj        # RStudio project file\n```\n\n. . .\n\nEach file should start with\n\n```cpp\n#include <Rcpp.h>\nusing namespace Rcpp; // Optional\n```\n\n## Sum Functions\n\nLet's see if we can beat R's own `sum()` (See\n[here](https://github.com/wch/r-source/blob/3b69aff4083ee81d6c4fe7177eb2b2a2ca41a240/src/main/summary.c#L152)\nfor the implementation.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- runif(1e5)\nbench::mark(sum(x), sum_cpp(x), sum_r(x)) |>\n  plot()\n```\n\n::: {.cell-output-display}\n![](lecture11_files/figure-beamer/bench-sum-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Exercise\n\nWrite a C++ function `cpp_mean()` that computes the arithmetic mean of a numeric\ninput vector.\n\nBenchmark your function against `mean()`.\n\n## Constants\n\n- In C++, we can use `const` to declare constants.\n- After declaration, the value cannot be changed.\n- Can lead to _marginal_ performance improvements.\n\n```cpp\nconst double pi = 3.14159;\npi = 3.14; // Error!\n```\n\n### `Const` Correctness\n\n- Enforce immutability wherever appropriate.\n- Can help avoid bugs.\n- Up to you\n\n## Passing by Reference\n\n- Useful to avoid copying large objects or when we want to modify the input.\n- Post-fix `&` to the type.\n\n\n::: {.cell}\n\n```{.cpp .cell-code}\n// [[Rcpp::export]]\ndouble sum_cpp_ref(Rcpp::NumericVector& x) {\n  double total = 0.0;\n  const int n = x.size();\n\n  for (int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n\n  return total;\n}\n```\n:::\n\n\n. . .\n\n### Rcpp Objects Reference R Objects\n\n- Modifing the Rcpp object modifies the original object.\n- Little point in using `&` in **exported** functions.\n\n## Const Reference\n\n- If you don't want to modify the input, you can pass by const reference.\n- Pre-fix `const` to the type.\n\n\n::: {.cell}\n\n```{.cpp .cell-code}\n// [[Rcpp::export]]\ndouble sum_cpp_const_ref(const Rcpp::NumericVector& x) {\n  double total = 0.0;\n  const int n = x.size();\n\n  for (int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n\n  return total;\n}\n```\n:::\n\n\n- In C++, this can make a big difference.\n- But with Rcpp, it makes little difference.\n- Sometimes no difference with standard C++ too.\n\n### Value of Constant References\n\n\n::: {.cell}\n\n```{.cpp .cell-code}\nNumericVector f_copy(NumericVector x) {\n  return pow(x, 2);\n}\n\nNumericVector f_constref(const NumericVector& x) {\n  return pow(x, 2);\n}\n\n// [[Rcpp::export]]\nNumericVector f_copyref(const bool copy) {\n  NumericVector x = runif(100000);\n  if (copy) {\n    return f_copy(x);\n  } else {\n    return f_constref(x);\n  }\n}\n```\n:::\n\n\n### Benchmark\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  f_copyref(TRUE),\n  f_copyref(FALSE),\n  check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 6\n  expression        min median `itr/sec` mem_alloc\n  <bch:expr>      <bch> <bch:>     <dbl> <bch:byt>\n1 f_copyref(TRUE) 378us  415us     2330.        NA\n2 f_copyref(FALS~ 373us  413us     2410.        NA\n# i 1 more variable: `gc/sec` <dbl>\n```\n\n\n:::\n:::\n\n\n## Sugar\n\n- Rcpp contains a wealth of syntactic **sugar**\n- Often versions of R's vectorized functions\n\n\n::: {.cell}\n\n```{.cpp .cell-code}\n// [[Rcpp::export]]\ndouble sum_cpp_sugar(const Rcpp::NumericVector& x) {\n  return Rcpp::sum(x);\n}\n```\n:::\n\n\n## Premature Optimization\n\n- Most C++ compilers will optimize the code for you.\n- What you see in the source code is **not** what you get.\n- Temporary variables are often optimized away.\n- Copy elisions\n\n## Exercise\n\n- Implement `cpp_sd()` using Rcpp that computes the standard deviation of a\n  (numeric) vector. Benchmark against `sd()`.\n- Remember to test your functions.\n- Don't use `Rcpp:sd()`, please ☺\n- If you have time over, try a different algorithm for computing the standard\n  deviation.\n\n\n::: {.cell}\n\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lecture11_files/figure-beamer/sd-bench-1.pdf)\n:::\n:::\n\n\n## Von Mises Rejection Sampling\n\n### For-Loop Version\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrvonmises <- function(n, kappa) {\n  y <- numeric(n)\n  for (i in 1:n) {\n    reject <- TRUE\n    while (reject) {\n      y0 <- runif(1, -pi, pi)\n      u <- runif(1)\n      reject <- u > exp(kappa * (cos(y0) - 1))\n    }\n    y[i] <- y0\n  }\n  y\n}\n```\n:::\n\n\n### Vectorized Version\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_sampler <- function(generator) {\n  alpha <- 1\n  function(n, ...) {\n    y <- list()\n    j <- 1\n    l <- 0\n    while (l < n) {\n      m <- ceiling((n - l) / alpha)\n      y[[j]] <- generator(m, ...)\n      l <- l + length(y[[j]])\n      if (j == 1) {\n        alpha <<- (l + 1) / (m + 1)\n      }\n      j <- j + 1\n    }\n    unlist(y)[1:n]\n  }\n}\n```\n:::\n\n\n:::\n\n::: {.column width=\"47%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvonmises_generator <- function(m, kappa) {\n  y <- runif(m, -pi, pi)\n  u <- runif(m)\n  accept <- u <= exp(kappa * (cos(y) - 1))\n  y[accept]\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrvonmises_vec <-\n  new_sampler(vonmises_generator)\n```\n:::\n\n\n:::\n\n::::\n\n### Rcpp Implementation\n\n\n::: {.cell}\n\n```{.cpp .cell-code}\n// [[Rcpp::export]]\nNumericVector rvonmises_cpp(const int n, const double kappa) {\n  NumericVector y(n);\n  int i = 0;\n\n  while (i < n) {\n    double y0 = R::runif(-M_PI, M_PI);\n    bool accept = R::runif(0, 1) <= exp(kappa * (cos(y0) - 1));\n    if (accept) {\n      y[i] = y0;\n      i++;\n    }\n  }\n\n  return y;\n}\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lecture11_files/figure-beamer/vMsim3-1.pdf)\n:::\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lecture11_files/figure-beamer/vMsim-cpp-runtime-1.pdf)\n:::\n:::\n\n\n## The Standard Template Library (STL)\n\n- A library of generic algorithms, data structures, and iterators for C++. --\n\n- Accessed via the `std` namespace.\n- Provides a number of useful functions for working with vectors and other\n  containers.\n\n. . .\n\n### Efficiently Growing Vectors\n\nUnlike R and Rcpp vector, `std::vector()` grows efficiently.\n\n```cpp\nstd::vector<int> x;\n\nfor (int i = 0; i < 10; ++i) {\n  x.emplace_back(i)\n}\n```\n\n## Linear Algebra\n\n### RcppArmadillo\n\n```cpp\n#include <RcppArmadillo.h>\n// [[Rcpp::depends(RcppArmadillo)]]\n// [[Rcpp::export]]\narma::mat armaMatrixMultiply(const arma::mat &A, const arma::mat &B) {\n  return A * B;\n}\n```\n\n. . .\n\n### RppEigen\n\n```cpp\n#include <RcppEigen.h>\n// [[Rcpp::depends(RcppEigen)]]\n// [[Rcpp::export]]\nEigen::MatrixXd eigenMatrixMultiply(const Eigen::MatrixXd &A,\n                                    const Eigen::MatrixXd &B) {\n  return A * B;\n}\n```\n\n## R Markdown\n\nCan put the code in Rcpp chunks, which will be automatically compiled and\nexported.\n\n\n::: {.cell}\n\n:::\n\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n\n<!-- prettier-ignore-start -->\n\n```{Rcpp}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nbool is_odd_cpp(int num = 10) {\n   bool result = (num % 2 == 1);\n   return result;\n}\n```\n````\n\n<!-- prettier-ignore-end -->\n\n:::\n\n::: {.column width=\"47%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_odd_cpp(7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n::::\n\n## Packages\n\n- Best practice for Rcpp code is actually to write a package.\n- Not as complicated as you might think!\n- Facilitates reproducibility\n- If we have time, we might cover in course.\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n\n### R Packages\n\nGreat book to get started; free and available online at <https://r-pkgs.org>.\n\n:::\n\n::: {.column width=\"47%\"}\n\n![](../images/r-pkgs.png)\n\n:::\n\n::::\n\n## Exercise\n\nRecall the running mean implementation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_mean <- function(y, k) {\n  n <- length(y)\n  m <- floor((k - 1) / 2)\n  k <- 2 * m + 1\n  y <- y / k\n  s <- rep(NA, n)\n  s[m + 1] <- sum(y[1:k])\n  for (i in (m + 1):(n - m - 1)) {\n    s[i + 1] <- s[i] - y[i - m] + y[i + 1 + m]\n  }\n  s\n}\n```\n:::\n\n\n- Rewrite this in Rcpp and compare the performance.\n- Test your implementation\n- Benchmark it against `run_mean()`\n\n\n::: {.cell}\n\n:::\n\n\n### Testing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(testthat)\n\ntest_that(\"R and C++ running mean functions are equivalent\", {\n  y <- rnorm(7)\n  expect_equal(run_mean(y, k = 3), run_mean_cpp(y, k = 3))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTest passed \n```\n\n\n:::\n:::\n\n\n### Benchmarking\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- rnorm(4096)\nrun_bench <- bench::press(\n  n = c(512, 1024, 2048, 4096),\n  {\n    y <- rnorm(n)\n    bench::mark(\n      run_mean(y, k = 11),\n      run_mean_cpp(y, k = 11),\n      check = FALSE\n    )\n  }\n)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lecture11_files/figure-beamer/plot-bench-1.pdf)\n:::\n:::\n\n\n## Getting Help\n\n- [The unofficial Rcpp API documentation](https://thecoatlessprofessor.com/programming/cpp/unofficial-rcpp-api-documentation/)\n- [The many official vignettes](https://cran.r-project.org/web/packages/Rcpp/index.html)\n- [Rcpp For Everyone](https://teuder.github.io/rcpp4everyone_en/) by Masaki E.\n  Tsuda\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}