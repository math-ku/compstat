{
  "hash": "b44a79863659b138978571f75dd1705e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Packages and Wrap-Up\"\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n## Today\n\n### Distributing and Organizing Code\n\nWorkshop in creating an R package\n\n### Course Summary\n\nWhat did we actually do?\n\n### Oral Examination Prep (Afternoon Session)\n\nWhat to think of during examination\n\n---\n\n## Organizing Code as an R Package\n\n---\n\n## Organizing Code\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n### Components\n\n- Code for experiments\n- Source code for functions (which we should be able to reuse)\n- Tests\n- Rcpp code\n- Data\n\nThere are many ways to organize this. Which one to choose?\n\n:::\n\n::: {.column width=\"45%\"}\n\n### R Package\n\nOne way is to make an R package, makes it easy to\n\n- connect to C++ code through Rcpp,\n- set up automatic testing,\n- document your code, and\n- declare dependencies (other packages, R version).\n\n:::\n\n::::\n\n---\n\n## R Packages\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n\nDifferent approaches, but we will follow **R Packages**\n[@wickhamPackagesOrganizeTest2023], which is based around the **devtools**\npackage.\n\n:::\n\n::: {.column width=\"47%\"}\n\n![R Packages](../images/rpkgs-cover-2e-small.png)\n\n:::\n\n::::\n\n---\n\n## Devtools\n\nMeta-package for various helpers that aid in developing R packages (and\nprojects).\n\nFirst off, install and load **devtools**:\n\n```r\ninstall.packages(\"devtools\")\nlibrary(devtools)\n```\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\nThis loads other packages that will be useful for setting up your package, most\nimportantly the **usethis** package.\n\n:::\n\n::: {.column width=\"45%\"}\n\n![](../images/usethis-logo.png)\n\n![](../images/devtools.pdf)\n\n:::\n\n::::\n\n---\n\n## A Toy Example\n\n### Rosenbrock Package\n\nLet's build a simple package that solves the Rosenbrock optimization problem,\ni.e. find\n\n$$\nx^* = \\operatorname{arg\\,min}\\left((a - x_1)^2 + b(x_2 - x_1^2)^2\\right).\n$$\n\n### What We Will Learn\n\n- Adding R functions to our package\n- Testing our code\n- Interfacing with Rcpp\n- Adding dependencies to other packages\n- Licensing our package\n- Documenting the code\n\n---\n\n## A First Package\n\n### Create It\n\nCall\n\n```r\nusethis::create_package(\"rosenbrock\")\n```\n\nor use `File > New Project > New Directory > R Package using devtools` in R\nStudio.\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\nGives you a **minimal** package:\n\n<!--prettier-ignore-start-->\n\n\\dirtree{%\n  .1 rosenbrock/.\n  .2 R/.\n  .2 DESCRIPTION.\n  .2 NAMESPACE.\n}\n\n<!--prettier-ignore-end-->\n\nYou may also have `.Rbuildignore` and `.rosenbrock.Rproj` depending on how you\ncreated the package.\n\n:::\n\n::: {.column width=\"45%\"}\n\n### Install It\n\nOpen up the package in your editor (R Studio\\footnote{In which case it should\nalready be opened.}).\n\n```r\ndevtools::install()\n```\n\nVoila, you have made an R package!\n\n:::\n\n::::\n\n## R Code\n\n### `R/`\n\n- All R code should live in `.R`-files in `R/`.\n- These files should (almost) always contain **only** functions.\n- Many ways to organize your files: one function per file, all functions of a\n  certain S3 class in one file etc.\n\nLet's create a first file: `R/objective.R`. Use `usethis::use_r(\"objective\")`\nand insert this:\n\n```r\nobjective <- function(x, a = 1, b = 100) {\n  (a - x[1])^2 + b * (x[2] - x[1]^2)^2\n}\n```\n\n## Workflow\n\nWe have created a first R file, but how do we use it? Two major options:\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n### devtools::install()\n\nInstalls the package, like calling `install.packages()`.\n\nRobust but slow. Need to call `library(rosenbrock)` to load\npackage\\footnote{Done automatically in R Studio}.\n\n:::\n\n::: {.column width=\"45%\"}\n\n### `devtools::load_all()`\n\nSources all of your code.\n\nQuick but not as robust.\n\n:::\n\n::::\n\n---\n\n### Try It\n\nTry both options and see if you can call your newly defined function,\n`objective()`.\n\n---\n\n![The various states of a package and how to move between them.](../images/install-load-states.png)\n\n---\n\n## Exporting Functions\n\nIf you called `devtools::load_all()` then everything is sourced and you can just\ncall `objective()` directly.\n\nBut if you use `devtools::install()` and `library(rosenbrock)`, then you would\nneed to use `rosenbrock:::objective()`. The reason is that the function is not\nyet exported.\n\n### NAMESPACE\n\nDecides what functions you want exported. But right now it just contains a\ncomment:\n\n```r\n# Generated by roxygen2: do not edit by hand\n```\n\nIf you want to just export everything, you can remove this file and recreate it\nwith this content:\n\n```r\nexportPattern(\"^[[:alpha:]]+\")\n```\n\n---\n\n## roxygen2\n\n**roxygen2** is a package that helps with package\ndocumentation[^more-on-this-later], but it can also be used for handling the\nnamespace.\n\n[^more-on-this-later]: More on this later.\n\nTo export a function, you need to place a special roxygen2 comment just before\nthe function:\n\n```r\n#' @export\n```\n\nGo ahead and place this before your `objective()` definition. Then run\n`devtools::document()` to roxygenize your package.\n\nNow `NAMESPACE` will (should) contain this:\n\n```r\nexport(objective)\n```\n\nReinstall the package and see if you can call `objective()` after loading it.\n\n---\n\n## Tests\n\n### testthat\n\n- We have already encountered **testthat** for writing tests in a formalized\n  way.\n- But **testthat** was actually written especially for packages.\n\nLet's start using **testthat** with our package:\n\n```r\nusethis::use_testthat()\n```\n\nThis creates some new files and directories:\n\n<!--prettier-ignore-start-->\n\n\\dirtree{%\n  .1 rosenbrock/.\n  .2 tests/.\n  .3 testthat/.\n  .4 test-<some-fun>.R.\n  .3 testthat.R.\n}\n\n<!--prettier-ignore-end-->\n\n---\n\n## A First Simple Test\n\nFor the Rosenbrock function, \\(f^\\* = f(a,a^2) = f(1,1) = 0\\). Let's make sure\nthis is the case for us too!\n\nTo create a test, we can use `usethis::use_test()`.\n\nCall `use_test(\"objective\")` (it's good practice to name the test file the same\nas the file where the function you're testing is defined) and insert this:\n\n```r\ntest_that(\"multiplication works\", {\n  # add a test using expect_equal()\n})\n```\n\n### Check That Everything Works\n\nRun `devtools::test()`, and hopefully see:\n\n```\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n```\n\n---\n\n## Checking\n\n### R CMD check\n\nR contains functionality for checking that your package is built correctly and\nyou can access this functionality through `devtools::check()`.\n\nNo requirement that your package needs to pass these checks (if you're using it\nas a project), but it's good practice to make sure it does.\n\n- **ERROR**: Major problem with your package\n- **WARNING**: Something that is most likely not great but not critical\n- **NOTE**: Typically small issues with your package\n\nNow run `devtools::check()`. Is there a problem? Yes, let's fix it!\n\n---\n\n## Metadata\n\nThe metadata for your package lives in `DESCRIPTION`. Right now it looks like\nthis:\n\n```\nPackage: rosenbrock\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R:\n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"),\n           comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.2\n```\n\nFor now we'll leave most of these files alone, but let's fix one thing: the\nlicense\n\n---\n\n## Licensing\n\n### Why Do You Need a License?\n\n- Licensing software tells other people about how they are allowed to reuse your\n  code.\n- If you do not provide a license, this generally means that **nobody is allowed\n  to copy, distribute, or modify your code.**\n- If you have other contributors, then \"nobody\" includes **you too!**\n\n---\n\n### Choosing a License\n\nSo we need to pick a license: for now we'll pick the MIT license.  \n(Read more about picking a license at <https://choosealicense.com>.)\n\n```r\nusethis::use_mit_license()\n```\n\nThis will add new files to your package: `LICENSE`, `LICENSE.md`, and modify\n`DESCRIPTION`, in which you should see:\n\n```\nLicense: MIT + file LICENSE\n```\n\n## Dependencies\n\nIn R packages, you make dependencies explicit, defined in `DESCRIPTION`.\n\n### Gradient\n\nLet's say that we want to compute the gradient for the Rosenbrock function.\n\nOne way to do so is to use numerical differentiation through the **numDeriv**\npackage:\n\n```r\ngradient <- function(x, a = 1, b = 100) {\n  numDeriv::grad(objective, x, a = a, b = b)\n}\n```\n\nNow our package depends on **numDeriv**, so we need to add it to `DESCRIPTION`:\n\n```r\nusethis::use_package(\"numDeriv\")\n```\n\nIn `DESCRIPTION`, you should now see this:\n\n```\nImports:\n  numDeriv\n```\n\n---\n\n## Rcpp\n\n:::: {.columns}\n\n::: {.column width=\"48%\"}\n\nRcpp works best in a package:\n\n- No more manual sourcing (no need to call `Rcpp::sourceCpp()`)\n- You don't need to add directives for dependencies to **RcppArmadillo** and\n  other packages.\n\nWe will rely on **roxygen2**. First, call\n\n```r\nusethis::use_package_doc()\n```\n\nto set up a package doc file in `R/rosenbrock-package.R`.\n\n:::\n\n::: {.column width=\"42%\"}\n\nThen use `usethis::use_rcpp()` to put the pieces in place:\n\n```\nrosenbrock/\n└── src/\n    └── slop-package.cpp/\n```\n\nNow just need to run `devtools::document()` and `devtools::load_all()` or\n`devtools::install()` and now your code is available (but not exported).\n\n:::\n\n::::\n\n---\n\n## Exporting Rcpp Code\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n### Wrapping\n\nCall your Rcpp function through an R wrapper:\n\n```r\nmy_fun <- function(x) {\n  my_fun_cpp(x)\n}\n```\n\nTypically easier because checking input and preparing output is easier on the R\nside.\n\n:::\n\n::: {.column width=\"45%\"}\n\n### Direct Export\n\nYou can add roxygen2 comments in Rcpp code too:\n\n```cpp\n//' @export\ndouble my_fun_cpp() { ... }\n```\n\nSaves you having to write and maintain an R function.\n\n:::\n\n::::\n\n---\n\n## Documentation\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n### Why?\n\nBecause\n\n- you make your code accessible to others,\n- it makes you think an extra time about what your function is doing, and\n- your future self will thank you.\n\n:::\n\n::: {.column width=\"45%\"}\n\n### Types\n\n- Comments in code\n- Manual (help files)\n- Long-form articles (vignettes)\n\n:::\n\n::::\n\n### roxygen2\n\nPrimary purpose of the package. You write code in a special syntax and it\nconverts it into manual files that R understands.\n\n## roxygen2 Syntax\n\n```r\n#' Function Title\n#'\n#' Here you describe what the function does, possibly\n#' using several lines.\n#'\n#' @param x Explanation of argument x\n#'\n#' @return Explanation of what the function returns\n#'\n#' @export\nmy_fun <- function(x) {\n  ...\n}\n```\n\n### Your Turn\n\nDocument `objective()` with roxygen2 syntax. No need for sensible documentation.\nJust make sure you have the bare minimum.\n\n---\n\n## Documentation in This Course\n\n- Not making a package for CRAN, so lower standards.\n- You don't need to document to benefit from building a package.\n- But it's not a bad idea to do so anyway!\n\n---\n\n![The whole game](../images/pkgs-workflow.png)\n\n---\n\n## Projects\n\nWhen you have a project, you typically need more things:\n\n- scripts with simulations, etc, which produce output\n- datasets stored in different formats\n- notebooks (or latex sources)\n\nThese things do not naturally fit into a package framework.\n\n---\n\n### Two Choices of Structure\n\n1. Just store these things directly into the package folder. Optionally, you can\n   use `.Rbuildignore` to ignore these files when building the package.\n2. Put your **package** into a _subdirectory_ of your project. This cleanly\n   separates the part of your project that contains reusable code (the package)\n   and the part that is experiments and reports. But a little trickier to setup.\n\n## Exercise: Two Options\n\n### Rosenbrock\n\nContinue building the **rosenbrock** package:\n\n- Write a gradient descent (or stochastic gradient descent) implementation that\n  minimizes the rosenbrock function.\n- Write the code in Rcpp. If you want, you can first write it in R to see that\n  everything is working, and then port it.\n- Feel free to use generative AI to write the code.\n- Export everything and document the package.\n\n### An Assignment\n\nStart trying to convert your work for one assignment into a package\n\n---\n\n## What We Didn't Cover\n\n- Version control through git and github\n- How to properly format metadata (`DESCRIPTION`)\n- Integrating data into our package\n- Publishing to CRAN\n- Principled approaches to reproducibility (renv, containers)\n\n---\n\n## Oral Examination Prep\n\n---\n\n## Procedure\n\n1. After entering the room you will connect the computer and check that it works\n   with the projector.\n2. When all technical issues are settled, you will draw the assignment and find\n   the presentation on the computer.\n3. Time starts and you have 15 min for the presentation. The examiners may ask\n   questions if something needs to be clarified.\n4. After 15 min your presentation will be stopped, and the examiners will ask\n   questions related to the assignment as well as to the general content of the\n   course.\n5. After at most 25 min the exam ends, and after assessment you will be given a\n   grade.\n\n# References\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}