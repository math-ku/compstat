{
  "hash": "b1a799bc5abc35a9c0d3bba7ab548b90",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Assignment 1\nsubtitle: Smoothing\nimage: ../assets/images/assignment1.svg\ndescription:\n  Implement and test kernel density estimation and bivariate smoothing spline\n  with bandwidth selection, comparing results to R's built-in functions.\n---\n\n\n\nThe first assignment topic is smoothing. If you draw the topic \"smoothing\" at\nthe oral exam, you will have to present a solution of one of the two assignments\nbelow.\n\nFor all assignments in the course you should have the following five points in\nmind:\n\n- How can you test that your implementation is correct?\n- Can you implement alternative solutions?\n- Can the code be restructured e.g. by modularization, abstraction or object\n  oriented programming to improve generality, extendability and readability?\n- How does the implementation perform (benchmarking)?\n- Where are the bottlenecks (profiling), and what can you do about them?\n\nSome of these points are not covered yet (or you just don't master them right\nnow), and you may need to return to your solution later in the course to improve\nand refine it. Moreover, the five points are not independent. Alternative\nsolutions may provide ways of testing the implementation. Restructuring of code\nmay improve or hurt performance. Optimization of performance may improve or hurt\nreadability. And so on.\n\n# A: Density Estimation\n\nImplement a kernel density estimator using the Epanechnikov kernel,\n$$K(x) = \\frac{3}{4}(1 - x^2) 1_{[-1, 1]}(x),$$ and implement one or more\nbandwidth selection algorithms using either AMISE plug-in methods or\ncross-validation methods. Test the implementation and compare the results with\nthe results of using `density()` in R.\n\nIt may be a good idea to use real data to investigate how the bandwidth\nselection works, but for benchmarking and profiling it is best to use simulated\ndata. Think about how to make your implementation as general and generic as\npossible.\n\n# B: Bivariate Smoothing\n\nImplement a smoothing spline smoother using LOOCV for selecting the tuning\nparameter $\\lambda$. Test the implementation and compare the results with the\nresults of using the R function `smooth.spline()`.\n\nA natural implementation relies on B-spline basis functions and their\nderivatives. These can be computed using the `splineDesign()` function from the\nbase R package **splines**^[You don't need to download this. It should already\nbe included in your installation of R.] and numerical integration. Riemann-sum\napproximations can be used, but using Simpson's rule with breakpoints in the\nknots, the numerical integral becomes exact. Alternatively, the function\n`bsplinepen()` from the [fda](https://CRAN.R-project.org/package=fda) package\ncan be used.\n\nIn addition to testing your implementation on real data it is a good idea to\nconsider simulated data as well. In particular for benchmarking and profiling.\nNote that the teaching material covers some matrix decomposition techniques that\ncan be particularly relevant in combination with LOOCV.\n\n```\n\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}